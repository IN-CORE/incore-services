//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.11 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2017.01.04 at 03:10:13 PM CST 
//


package Metadata.Specifications.DDI.LifeCycle.datacollection;

import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElements;
import javax.xml.bind.annotation.XmlType;

import Metadata.Specifications.DDI.LifeCycle.reusable.CoverageType;
import Metadata.Specifications.DDI.LifeCycle.reusable.LabelType;
import Metadata.Specifications.DDI.LifeCycle.reusable.MaintainableType;
import Metadata.Specifications.DDI.LifeCycle.reusable.NameType;
import Metadata.Specifications.DDI.LifeCycle.reusable.OtherMaterialType;
import Metadata.Specifications.DDI.LifeCycle.reusable.ReferenceType;
import Metadata.Specifications.DDI.LifeCycle.reusable.SchemeReferenceType;
import Metadata.Specifications.DDI.LifeCycle.reusable.StructuredStringType;


/**
 * A maintainable module containing information on activities related to data collection/capture and the processing required for the creation a data product. This section covers the methodologies, events, data sources, collection instruments and processes which comprise the collection/capture and processing of data. Methodology covers approaches used for selecting samples, administering surveys, timing repeated data collection activities. Collection Event specifies data sources, collection instruments, questions and question flow, and data processing activities. This module houses Processing Instructions (General Instructions and Generation Instructions) which may be referenced by variables or comparison maps.The module is described by a name, label, and description, provides spatial, temporal, and topical coverage information on the activities covered by the module, and references to external material related to objects in the module using OtherMaterial. The content of the module is organized within the following sections; Methodology, Collection Event, QuestionScheme (in-line or by reference), ControlConstructScheme (in-line or by references) containing the flow of a questionnaire or data capture process, InterviewerInstructionScheme (in-line or by reference), InstrumentScheme (in-line or by reference) and ProcessingEventScheme (in-line or by reference).
 * <p>
 * <p>Java class for DataCollectionType complex type.
 * <p>
 * <p>The following schema fragment specifies the expected content contained within this class.
 * <p>
 * <pre>
 * &lt;complexType name="DataCollectionType"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{ddi:reusable:3_2}MaintainableType"&gt;
 *       &lt;sequence&gt;
 *         &lt;element ref="{ddi:datacollection:3_2}DataCollectionModuleName" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}Label" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}Description" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}Coverage" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}OtherMaterial" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;choice minOccurs="0"&gt;
 *           &lt;element ref="{ddi:datacollection:3_2}Methodology"/&gt;
 *           &lt;element ref="{ddi:datacollection:3_2}MethodologyReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;element ref="{ddi:datacollection:3_2}CollectionEvent" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:datacollection:3_2}QuestionScheme"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}QuestionSchemeReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:datacollection:3_2}ControlConstructScheme"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}ControlConstructSchemeReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:datacollection:3_2}InterviewerInstructionScheme"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}InterviewerInstructionSchemeReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:datacollection:3_2}InstrumentScheme"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}InstrumentSchemeReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:datacollection:3_2}ProcessingEventScheme"/&gt;
 *           &lt;element ref="{ddi:datacollection:3_2}ProcessingEventSchemeReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:datacollection:3_2}ProcessingInstructionScheme"/&gt;
 *           &lt;element ref="{ddi:datacollection:3_2}ProcessingInstructionSchemeReference"/&gt;
 *         &lt;/choice&gt;
 *       &lt;/sequence&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "DataCollectionType", propOrder = {
        "dataCollectionModuleName",
        "label",
        "description",
        "coverage",
        "otherMaterial",
        "methodology",
        "methodologyReference",
        "collectionEvent",
        "questionSchemeOrQuestionSchemeReference",
        "controlConstructSchemeOrControlConstructSchemeReference",
        "interviewerInstructionSchemeOrInterviewerInstructionSchemeReference",
        "instrumentSchemeOrInstrumentSchemeReference",
        "processingEventSchemeOrProcessingEventSchemeReference",
        "processingInstructionSchemeOrProcessingInstructionSchemeReference"
})
public class DataCollectionType
        extends MaintainableType {

    @XmlElement(name = "DataCollectionModuleName")
    protected List<NameType> dataCollectionModuleName;
    @XmlElement(name = "Label", namespace = "ddi:reusable:3_2")
    protected List<LabelType> label;
    @XmlElement(name = "Description", namespace = "ddi:reusable:3_2")
    protected StructuredStringType description;
    @XmlElement(name = "Coverage", namespace = "ddi:reusable:3_2")
    protected CoverageType coverage;
    @XmlElement(name = "OtherMaterial", namespace = "ddi:reusable:3_2")
    protected List<OtherMaterialType> otherMaterial;
    @XmlElement(name = "Methodology")
    protected MethodologyType methodology;
    @XmlElement(name = "MethodologyReference")
    protected ReferenceType methodologyReference;
    @XmlElement(name = "CollectionEvent")
    protected List<CollectionEventType> collectionEvent;
    @XmlElements({
            @XmlElement(name = "QuestionScheme", type = QuestionSchemeType.class),
            @XmlElement(name = "QuestionSchemeReference", namespace = "ddi:reusable:3_2", type = SchemeReferenceType.class)
    })
    protected List<Object> questionSchemeOrQuestionSchemeReference;
    @XmlElements({
            @XmlElement(name = "ControlConstructScheme", type = ControlConstructSchemeType.class),
            @XmlElement(name = "ControlConstructSchemeReference", namespace = "ddi:reusable:3_2", type = SchemeReferenceType.class)
    })
    protected List<Object> controlConstructSchemeOrControlConstructSchemeReference;
    @XmlElements({
            @XmlElement(name = "InterviewerInstructionScheme", type = InterviewerInstructionSchemeType.class),
            @XmlElement(name = "InterviewerInstructionSchemeReference", namespace = "ddi:reusable:3_2", type = SchemeReferenceType.class)
    })
    protected List<Object> interviewerInstructionSchemeOrInterviewerInstructionSchemeReference;
    @XmlElements({
            @XmlElement(name = "InstrumentScheme", type = InstrumentSchemeType.class),
            @XmlElement(name = "InstrumentSchemeReference", namespace = "ddi:reusable:3_2", type = SchemeReferenceType.class)
    })
    protected List<Object> instrumentSchemeOrInstrumentSchemeReference;
    @XmlElements({
            @XmlElement(name = "ProcessingEventScheme", type = ProcessingEventSchemeType.class),
            @XmlElement(name = "ProcessingEventSchemeReference", type = SchemeReferenceType.class)
    })
    protected List<Object> processingEventSchemeOrProcessingEventSchemeReference;
    @XmlElements({
            @XmlElement(name = "ProcessingInstructionScheme", type = ProcessingInstructionSchemeType.class),
            @XmlElement(name = "ProcessingInstructionSchemeReference", type = SchemeReferenceType.class)
    })
    protected List<Object> processingInstructionSchemeOrProcessingInstructionSchemeReference;

    /**
     * A name for the DataCollection module. May be expressed in multiple languages. Repeat the element to express names with different content, for example different names for different systems.Gets the value of the dataCollectionModuleName property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the dataCollectionModuleName property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDataCollectionModuleName().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link NameType }
     */
    public List<NameType> getDataCollectionModuleName() {
        if (dataCollectionModuleName == null) {
            dataCollectionModuleName = new ArrayList<NameType>();
        }
        return this.dataCollectionModuleName;
    }

    /**
     * A display label for the DataCollection module. May be expressed in multiple languages. Repeat for labels with different content, for example, labels with differing length limitations.Gets the value of the label property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the label property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getLabel().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link LabelType }
     */
    public List<LabelType> getLabel() {
        if (label == null) {
            label = new ArrayList<LabelType>();
        }
        return this.label;
    }

    /**
     * A description of the content and purpose of the DataCollection module. May be expressed in multiple languages and supports the use of structured content.
     *
     * @return possible object is
     * {@link StructuredStringType }
     */
    public StructuredStringType getDescription() {
        return description;
    }

    /**
     * Sets the value of the description property.
     *
     * @param value allowed object is
     *              {@link StructuredStringType }
     */
    public void setDescription(StructuredStringType value) {
        this.description = value;
    }

    /**
     * Documents the spatial, temporal, and/or topical coverage of the data collection module.
     *
     * @return possible object is
     * {@link CoverageType }
     */
    public CoverageType getCoverage() {
        return coverage;
    }

    /**
     * Sets the value of the coverage property.
     *
     * @param value allowed object is
     *              {@link CoverageType }
     */
    public void setCoverage(CoverageType value) {
        this.coverage = value;
    }

    /**
     * Contains references to other materials relevant to the data collection module, whether in DDI form or external. Links can be made from items in this section to any identifiable element in the instance. Best practice is to include OtherMaterial inside the maintainable containing the objects that are related to the OtherMaterial.Gets the value of the otherMaterial property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the otherMaterial property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getOtherMaterial().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link OtherMaterialType }
     */
    public List<OtherMaterialType> getOtherMaterial() {
        if (otherMaterial == null) {
            otherMaterial = new ArrayList<OtherMaterialType>();
        }
        return this.otherMaterial;
    }

    /**
     * Metadata regarding the methodology of the data collection process including, determining repetition patterns, sampling, collection modes, etc.
     *
     * @return possible object is
     * {@link MethodologyType }
     */
    public MethodologyType getMethodology() {
        return methodology;
    }

    /**
     * Sets the value of the methodology property.
     *
     * @param value allowed object is
     *              {@link MethodologyType }
     */
    public void setMethodology(MethodologyType value) {
        this.methodology = value;
    }

    /**
     * Reference to metadata regarding the methodology of the data collection process including, determining repetition patterns, sampling, collection modes, etc. TypeOfObject should be set to Methodology.
     *
     * @return possible object is
     * {@link ReferenceType }
     */
    public ReferenceType getMethodologyReference() {
        return methodologyReference;
    }

    /**
     * Sets the value of the methodologyReference property.
     *
     * @param value allowed object is
     *              {@link ReferenceType }
     */
    public void setMethodologyReference(ReferenceType value) {
        this.methodologyReference = value;
    }

    /**
     * A specific event in the collection or capture process.Gets the value of the collectionEvent property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the collectionEvent property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCollectionEvent().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CollectionEventType }
     */
    public List<CollectionEventType> getCollectionEvent() {
        if (collectionEvent == null) {
            collectionEvent = new ArrayList<CollectionEventType>();
        }
        return this.collectionEvent;
    }

    /**
     * Gets the value of the questionSchemeOrQuestionSchemeReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the questionSchemeOrQuestionSchemeReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getQuestionSchemeOrQuestionSchemeReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link QuestionSchemeType }
     * {@link SchemeReferenceType }
     */
    public List<Object> getQuestionSchemeOrQuestionSchemeReference() {
        if (questionSchemeOrQuestionSchemeReference == null) {
            questionSchemeOrQuestionSchemeReference = new ArrayList<Object>();
        }
        return this.questionSchemeOrQuestionSchemeReference;
    }

    /**
     * Gets the value of the controlConstructSchemeOrControlConstructSchemeReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the controlConstructSchemeOrControlConstructSchemeReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getControlConstructSchemeOrControlConstructSchemeReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ControlConstructSchemeType }
     * {@link SchemeReferenceType }
     */
    public List<Object> getControlConstructSchemeOrControlConstructSchemeReference() {
        if (controlConstructSchemeOrControlConstructSchemeReference == null) {
            controlConstructSchemeOrControlConstructSchemeReference = new ArrayList<Object>();
        }
        return this.controlConstructSchemeOrControlConstructSchemeReference;
    }

    /**
     * Gets the value of the interviewerInstructionSchemeOrInterviewerInstructionSchemeReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the interviewerInstructionSchemeOrInterviewerInstructionSchemeReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getInterviewerInstructionSchemeOrInterviewerInstructionSchemeReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link InterviewerInstructionSchemeType }
     * {@link SchemeReferenceType }
     */
    public List<Object> getInterviewerInstructionSchemeOrInterviewerInstructionSchemeReference() {
        if (interviewerInstructionSchemeOrInterviewerInstructionSchemeReference == null) {
            interviewerInstructionSchemeOrInterviewerInstructionSchemeReference = new ArrayList<Object>();
        }
        return this.interviewerInstructionSchemeOrInterviewerInstructionSchemeReference;
    }

    /**
     * Gets the value of the instrumentSchemeOrInstrumentSchemeReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the instrumentSchemeOrInstrumentSchemeReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getInstrumentSchemeOrInstrumentSchemeReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link InstrumentSchemeType }
     * {@link SchemeReferenceType }
     */
    public List<Object> getInstrumentSchemeOrInstrumentSchemeReference() {
        if (instrumentSchemeOrInstrumentSchemeReference == null) {
            instrumentSchemeOrInstrumentSchemeReference = new ArrayList<Object>();
        }
        return this.instrumentSchemeOrInstrumentSchemeReference;
    }

    /**
     * Gets the value of the processingEventSchemeOrProcessingEventSchemeReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the processingEventSchemeOrProcessingEventSchemeReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getProcessingEventSchemeOrProcessingEventSchemeReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ProcessingEventSchemeType }
     * {@link SchemeReferenceType }
     */
    public List<Object> getProcessingEventSchemeOrProcessingEventSchemeReference() {
        if (processingEventSchemeOrProcessingEventSchemeReference == null) {
            processingEventSchemeOrProcessingEventSchemeReference = new ArrayList<Object>();
        }
        return this.processingEventSchemeOrProcessingEventSchemeReference;
    }

    /**
     * Gets the value of the processingInstructionSchemeOrProcessingInstructionSchemeReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the processingInstructionSchemeOrProcessingInstructionSchemeReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getProcessingInstructionSchemeOrProcessingInstructionSchemeReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ProcessingInstructionSchemeType }
     * {@link SchemeReferenceType }
     */
    public List<Object> getProcessingInstructionSchemeOrProcessingInstructionSchemeReference() {
        if (processingInstructionSchemeOrProcessingInstructionSchemeReference == null) {
            processingInstructionSchemeOrProcessingInstructionSchemeReference = new ArrayList<Object>();
        }
        return this.processingInstructionSchemeOrProcessingInstructionSchemeReference;
    }

}

//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.11 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2017.01.04 at 03:10:13 PM CST 
//


package Metadata.Specifications.DDI.LifeCycle.logicalproduct;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;

import Metadata.Specifications.DDI.LifeCycle.reusable.IdentifiableType;
import Metadata.Specifications.DDI.LifeCycle.reusable.LabelType;
import Metadata.Specifications.DDI.LifeCycle.reusable.NameType;
import Metadata.Specifications.DDI.LifeCycle.reusable.StructuredStringType;


/**
 * A logical record is a description of all of the elements (variables or NCubes) related to a single case or analysis unit. Required to link a description of a physical record structure to its logical record. In addition to the standard name, label, and description, the structure identifies the variable designating its record type, describes case identification within the record type, indicates support for multiple storage segments, and defines a default set of missing values used by the record. In a data set with multiple records repeat to describe each logical record, such as a household, family, person, or event, record. A LogicalRecord is required to link a description of a physical record structure to its logical record.
 * <p>
 * <p>Java class for LogicalRecordType complex type.
 * <p>
 * <p>The following schema fragment specifies the expected content contained within this class.
 * <p>
 * <pre>
 * &lt;complexType name="LogicalRecordType"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{ddi:reusable:3_2}IdentifiableType"&gt;
 *       &lt;sequence&gt;
 *         &lt;element ref="{ddi:logicalproduct:3_2}LogicalRecordName" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}Label" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}Description" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:logicalproduct:3_2}VariableValueReference" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:logicalproduct:3_2}SupportForMultipleSegments" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:logicalproduct:3_2}CaseIdentification" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;choice minOccurs="0"&gt;
 *           &lt;element ref="{ddi:logicalproduct:3_2}VariablesInRecord"/&gt;
 *           &lt;element ref="{ddi:logicalproduct:3_2}NCubesInRecord"/&gt;
 *         &lt;/choice&gt;
 *         &lt;element ref="{ddi:logicalproduct:3_2}DefaultMissingValues" minOccurs="0"/&gt;
 *       &lt;/sequence&gt;
 *       &lt;attribute name="hasLocator" type="{http://www.w3.org/2001/XMLSchema}boolean" /&gt;
 *       &lt;attribute name="variableQuantity" type="{http://www.w3.org/2001/XMLSchema}integer" /&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "LogicalRecordType", propOrder = {
        "logicalRecordName",
        "label",
        "description",
        "variableValueReference",
        "supportForMultipleSegments",
        "caseIdentification",
        "variablesInRecord",
        "nCubesInRecord",
        "defaultMissingValues"
})
public class LogicalRecordType
        extends IdentifiableType {

    @XmlElement(name = "LogicalRecordName")
    protected List<NameType> logicalRecordName;
    @XmlElement(name = "Label", namespace = "ddi:reusable:3_2")
    protected List<LabelType> label;
    @XmlElement(name = "Description", namespace = "ddi:reusable:3_2")
    protected StructuredStringType description;
    @XmlElement(name = "VariableValueReference")
    protected VariableValueReferenceType variableValueReference;
    @XmlElement(name = "SupportForMultipleSegments")
    protected VariableValueReferenceType supportForMultipleSegments;
    @XmlElement(name = "CaseIdentification")
    protected List<CaseIdentificationType> caseIdentification;
    @XmlElement(name = "VariablesInRecord")
    protected VariablesInRecordType variablesInRecord;
    @XmlElement(name = "NCubesInRecord")
    protected NCubesInRecordType nCubesInRecord;
    @XmlElement(name = "DefaultMissingValues")
    protected DefaultMissingValuesType defaultMissingValues;
    @XmlAttribute(name = "hasLocator")
    protected Boolean hasLocator;
    @XmlAttribute(name = "variableQuantity")
    protected BigInteger variableQuantity;

    /**
     * A name for the LogicalRecord. May be expressed in multiple languages. Repeat the element to express names with different content, for example different names for different systems.Gets the value of the logicalRecordName property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the logicalRecordName property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getLogicalRecordName().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link NameType }
     */
    public List<NameType> getLogicalRecordName() {
        if (logicalRecordName == null) {
            logicalRecordName = new ArrayList<NameType>();
        }
        return this.logicalRecordName;
    }

    /**
     * A display label for the LogicalRecord. May be expressed in multiple languages. Repeat for labels with different content, for example, labels with differing length limitations.Gets the value of the label property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the label property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getLabel().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link LabelType }
     */
    public List<LabelType> getLabel() {
        if (label == null) {
            label = new ArrayList<LabelType>();
        }
        return this.label;
    }

    /**
     * A description of the content and purpose of the LogicalRecord. May be expressed in multiple languages and supports the use of structured content.
     *
     * @return possible object is
     * {@link StructuredStringType }
     */
    public StructuredStringType getDescription() {
        return description;
    }

    /**
     * Sets the value of the description property.
     *
     * @param value allowed object is
     *              {@link StructuredStringType }
     */
    public void setDescription(StructuredStringType value) {
        this.description = value;
    }

    /**
     * A reference the variable containing the record type locator and the value being used. Files with single record types or which store records in different files may not have a record type locator. If this element is used set the attribute hasLocator to "true".
     *
     * @return possible object is
     * {@link VariableValueReferenceType }
     */
    public VariableValueReferenceType getVariableValueReference() {
        return variableValueReference;
    }

    /**
     * Sets the value of the variableValueReference property.
     *
     * @param value allowed object is
     *              {@link VariableValueReferenceType }
     */
    public void setVariableValueReference(VariableValueReferenceType value) {
        this.variableValueReference = value;
    }

    /**
     * Information concerning support for breaking the logical record into segments for storage purposes. Some files may be broken into record segments for storage but lack variables to support identification of specific segments. In this case segments are identified by their physical order within the storage file.
     *
     * @return possible object is
     * {@link VariableValueReferenceType }
     */
    public VariableValueReferenceType getSupportForMultipleSegments() {
        return supportForMultipleSegments;
    }

    /**
     * Sets the value of the supportForMultipleSegments property.
     *
     * @param value allowed object is
     *              {@link VariableValueReferenceType }
     */
    public void setSupportForMultipleSegments(VariableValueReferenceType value) {
        this.supportForMultipleSegments = value;
    }

    /**
     * Describes the information needed to identify an individual case within a record type. This may be the variable or concatenated variable used to identify a unique case of a particular record type. Often referred to as a unique key. There may be more than one means of identifying a record. For example a US Census Summary File has a LogicalRecordIdentifier that is unique to the original file within which it was published. A specific geography has a set of fields that uniquely identify it.Gets the value of the caseIdentification property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the caseIdentification property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCaseIdentification().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CaseIdentificationType }
     */
    public List<CaseIdentificationType> getCaseIdentification() {
        if (caseIdentification == null) {
            caseIdentification = new ArrayList<CaseIdentificationType>();
        }
        return this.caseIdentification;
    }

    /**
     * List of all variables used in the record, either directly or as found in a defined VariableGroup; note that a variable can be used in multiple records. The variables in the logical record can be noted by inclusion or exclusion to facilitate listing. The attribute allVariablesInLogicalProduct, when set to 'true', includes all variables in the LogicalProduct. VariableSchemeReference can then be used to exclude individual Variables schemes or include schemes from other logical products. In the same way VariableReference can be used to exclude specific variables from the previously defined variable set or include variables not already included. The simplest LogicalProduct descriptions with a single LogicalRecord can be described using only the attribute allVariablesInLogicalProduct with a value of true.
     *
     * @return possible object is
     * {@link VariablesInRecordType }
     */
    public VariablesInRecordType getVariablesInRecord() {
        return variablesInRecord;
    }

    /**
     * Sets the value of the variablesInRecord property.
     *
     * @param value allowed object is
     *              {@link VariablesInRecordType }
     */
    public void setVariablesInRecord(VariablesInRecordType value) {
        this.variablesInRecord = value;
    }

    /**
     * List of all NCubes used in the record, either directly or as found in a defined NCubeGroup; note that an NCube can be used in multiple records. The NCubes in the logical record can be noted by inclusion or exclusion to facilitate listing. The attribute allNCubesInLogicalProduct, when set to 'true', includes all NCubes in the LogicalProduct. NCubeSchemeReference can then be used to exclude individual NCubes schemes or include schemes from other logical products. In the same way NCubeReference can be used to exclude specific variables from the previously defined variable set or include variables not already included. The simplest LogicalProduct descriptions with a single LogicalRecord can be described using only the attribute allNCubesInLogicalProduct with a value of true.
     *
     * @return possible object is
     * {@link NCubesInRecordType }
     */
    public NCubesInRecordType getNCubesInRecord() {
        return nCubesInRecord;
    }

    /**
     * Sets the value of the nCubesInRecord property.
     *
     * @param value allowed object is
     *              {@link NCubesInRecordType }
     */
    public void setNCubesInRecord(NCubesInRecordType value) {
        this.nCubesInRecord = value;
    }

    /**
     * Identifies the default missing value parameter for the this logical record by referencing a ManagedMissingValuesRepresentation or by stating that there is a default missing values parameter used but it is undocumented. Note that a conflicting DefaultMissingValues definition in a PhysicalInstance will override that found in the LogicalRecord.
     *
     * @return possible object is
     * {@link DefaultMissingValuesType }
     */
    public DefaultMissingValuesType getDefaultMissingValues() {
        return defaultMissingValues;
    }

    /**
     * Sets the value of the defaultMissingValues property.
     *
     * @param value allowed object is
     *              {@link DefaultMissingValuesType }
     */
    public void setDefaultMissingValues(DefaultMissingValuesType value) {
        this.defaultMissingValues = value;
    }

    /**
     * Gets the value of the hasLocator property.
     *
     * @return possible object is
     * {@link Boolean }
     */
    public Boolean isHasLocator() {
        return hasLocator;
    }

    /**
     * Sets the value of the hasLocator property.
     *
     * @param value allowed object is
     *              {@link Boolean }
     */
    public void setHasLocator(Boolean value) {
        this.hasLocator = value;
    }

    /**
     * Gets the value of the variableQuantity property.
     *
     * @return possible object is
     * {@link BigInteger }
     */
    public BigInteger getVariableQuantity() {
        return variableQuantity;
    }

    /**
     * Sets the value of the variableQuantity property.
     *
     * @param value allowed object is
     *              {@link BigInteger }
     */
    public void setVariableQuantity(BigInteger value) {
        this.variableQuantity = value;
    }

}

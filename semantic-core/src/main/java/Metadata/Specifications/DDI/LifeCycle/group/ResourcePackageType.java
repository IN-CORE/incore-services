//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.11 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2017.01.04 at 03:10:13 PM CST 
//


package Metadata.Specifications.DDI.LifeCycle.group;

import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlElementRefs;
import javax.xml.bind.annotation.XmlElements;
import javax.xml.bind.annotation.XmlType;

import Metadata.Specifications.DDI.LifeCycle.archive.ArchiveType;
import Metadata.Specifications.DDI.LifeCycle.archive.OrganizationSchemeType;
import Metadata.Specifications.DDI.LifeCycle.comparative.ComparisonType;
import Metadata.Specifications.DDI.LifeCycle.conceptualcomponent.ConceptSchemeType;
import Metadata.Specifications.DDI.LifeCycle.conceptualcomponent.ConceptualComponentType;
import Metadata.Specifications.DDI.LifeCycle.conceptualcomponent.ConceptualVariableSchemeType;
import Metadata.Specifications.DDI.LifeCycle.conceptualcomponent.GeographicLocationSchemeType;
import Metadata.Specifications.DDI.LifeCycle.conceptualcomponent.GeographicStructureSchemeType;
import Metadata.Specifications.DDI.LifeCycle.conceptualcomponent.UniverseSchemeType;
import Metadata.Specifications.DDI.LifeCycle.datacollection.ControlConstructSchemeType;
import Metadata.Specifications.DDI.LifeCycle.datacollection.DataCollectionType;
import Metadata.Specifications.DDI.LifeCycle.datacollection.InstrumentSchemeType;
import Metadata.Specifications.DDI.LifeCycle.datacollection.InterviewerInstructionSchemeType;
import Metadata.Specifications.DDI.LifeCycle.datacollection.ProcessingEventSchemeType;
import Metadata.Specifications.DDI.LifeCycle.datacollection.ProcessingInstructionSchemeType;
import Metadata.Specifications.DDI.LifeCycle.datacollection.QuestionSchemeType;
import Metadata.Specifications.DDI.LifeCycle.ddiprofile.DDIProfileType;
import Metadata.Specifications.DDI.LifeCycle.logicalproduct.BaseLogicalProductType;
import Metadata.Specifications.DDI.LifeCycle.logicalproduct.CategorySchemeType;
import Metadata.Specifications.DDI.LifeCycle.logicalproduct.CodeListSchemeType;
import Metadata.Specifications.DDI.LifeCycle.logicalproduct.LogicalProductType;
import Metadata.Specifications.DDI.LifeCycle.logicalproduct.NCubeSchemeType;
import Metadata.Specifications.DDI.LifeCycle.logicalproduct.RepresentedVariableSchemeType;
import Metadata.Specifications.DDI.LifeCycle.logicalproduct.VariableSchemeType;
import Metadata.Specifications.DDI.LifeCycle.physicaldataproduct.PhysicalDataProductType;
import Metadata.Specifications.DDI.LifeCycle.physicaldataproduct.PhysicalStructureSchemeType;
import Metadata.Specifications.DDI.LifeCycle.physicaldataproduct.RecordLayoutSchemeType;
import Metadata.Specifications.DDI.LifeCycle.physicalinstance.PhysicalInstanceType;
import Metadata.Specifications.DDI.LifeCycle.reusable.AuthorizationSourceType;
import Metadata.Specifications.DDI.LifeCycle.reusable.BudgetType;
import Metadata.Specifications.DDI.LifeCycle.reusable.CitationType;
import Metadata.Specifications.DDI.LifeCycle.reusable.CodeValueType;
import Metadata.Specifications.DDI.LifeCycle.reusable.CoverageType;
import Metadata.Specifications.DDI.LifeCycle.reusable.EmbargoType;
import Metadata.Specifications.DDI.LifeCycle.reusable.FundingInformationType;
import Metadata.Specifications.DDI.LifeCycle.reusable.MaintainableType;
import Metadata.Specifications.DDI.LifeCycle.reusable.ManagedRepresentationSchemeType;
import Metadata.Specifications.DDI.LifeCycle.reusable.OtherMaterialType;
import Metadata.Specifications.DDI.LifeCycle.reusable.QualityStatementSchemeType;
import Metadata.Specifications.DDI.LifeCycle.reusable.ReferenceType;
import Metadata.Specifications.DDI.LifeCycle.reusable.SchemeReferenceType;
import Metadata.Specifications.DDI.LifeCycle.reusable.SeriesStatementType;
import Metadata.Specifications.DDI.LifeCycle.reusable.StructuredStringType;


/**
 * The Resource Package is a specialized structure which is intended to hold reusable metadata outside of the structures of a single StudyUnit or Group. For example this may be common methodological approaches bound in a DataCollection module, DataRelationship information bound in a LogicalProduct, or any maintainable scheme. The ResourcePackage is often used to manage and publish metadata that is used by StudyUnits or Groups by reference. Any maintainable object with the exception of a Group, StudyUnit or LocalHoldingPackage may be published in a Resource Package. Each maintainable object may be entered as either an in-line representation or by reference. Within each maintainable type the ordering of in-line or referenced content may be mixed. In addition the ResourcePackage contains self identifying information including: a citation, abstract, authorization source, a universe reference, series statement, references to applicable quality statements, funding and budget information, purpose, coverage, other material, embargo, and the resource package archive (as opposed to an Archive module intended as the part of the published reusable content).
 * <p>
 * <p>Java class for ResourcePackageType complex type.
 * <p>
 * <p>The following schema fragment specifies the expected content contained within this class.
 * <p>
 * <pre>
 * &lt;complexType name="ResourcePackageType"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{ddi:reusable:3_2}MaintainableType"&gt;
 *       &lt;sequence&gt;
 *         &lt;element ref="{ddi:reusable:3_2}Citation" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:group:3_2}TypeOfResourcePackage" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}Abstract" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}AuthorizationSource" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}UniverseReference" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}SeriesStatement" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}QualityStatementReference" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}FundingInformation" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:group:3_2}ProjectBudget" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}Purpose" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}Coverage" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}OtherMaterial" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}Embargo" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:group:3_2}ResourcePackageArchive" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:conceptualcomponent:3_2}ConceptualComponent"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}ConceptualComponentReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:datacollection:3_2}DataCollection"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}DataCollectionReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:logicalproduct:3_2}BaseLogicalProduct"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}LogicalProductReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:physicaldataproduct:3_2}PhysicalDataProduct"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}PhysicalDataProductReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:physicalinstance:3_2}PhysicalInstance"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}PhysicalInstanceReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:archive:3_2}Archive"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}ArchiveReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:ddiprofile:3_2}DDIProfile"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}DDIProfileReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:comparative:3_2}Comparison"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}ComparisonReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:archive:3_2}OrganizationScheme"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}OrganizationSchemeReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:conceptualcomponent:3_2}ConceptScheme"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}ConceptSchemeReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:conceptualcomponent:3_2}UniverseScheme"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}UniverseSchemeReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:conceptualcomponent:3_2}ConceptualVariableScheme"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}ConceptualVariableSchemeReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:logicalproduct:3_2}RepresentedVariableScheme"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}RepresentedVariableSchemeReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:conceptualcomponent:3_2}GeographicStructureScheme"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}GeographicStructureSchemeReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:conceptualcomponent:3_2}GeographicLocationScheme"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}GeographicLocationSchemeReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:datacollection:3_2}InterviewerInstructionScheme"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}InterviewerInstructionSchemeReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:datacollection:3_2}ControlConstructScheme"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}ControlConstructSchemeReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:datacollection:3_2}QuestionScheme"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}QuestionSchemeReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:logicalproduct:3_2}CategoryScheme"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}CategorySchemeReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:logicalproduct:3_2}CodeListScheme"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}CodeListSchemeReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:logicalproduct:3_2}NCubeScheme"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}NCubeSchemeReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:logicalproduct:3_2}VariableScheme"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}VariableSchemeReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:physicaldataproduct:3_2}PhysicalStructureScheme"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}PhysicalStructureSchemeReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:physicaldataproduct:3_2}RecordLayoutScheme"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}RecordLayoutSchemeReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:reusable:3_2}QualityStatementScheme"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}QualityStatementSchemeReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:datacollection:3_2}InstrumentScheme"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}InstrumentSchemeReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:datacollection:3_2}ProcessingEventScheme"/&gt;
 *           &lt;element ref="{ddi:datacollection:3_2}ProcessingEventSchemeReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:datacollection:3_2}ProcessingInstructionScheme"/&gt;
 *           &lt;element ref="{ddi:datacollection:3_2}ProcessingInstructionSchemeReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:reusable:3_2}ManagedRepresentationScheme"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}ManagedRepresentationSchemeReference"/&gt;
 *         &lt;/choice&gt;
 *       &lt;/sequence&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "ResourcePackageType", propOrder = {
        "citation",
        "typeOfResourcePackage",
        "_abstract",
        "authorizationSource",
        "universeReference",
        "seriesStatement",
        "qualityStatementReference",
        "fundingInformation",
        "projectBudget",
        "purpose",
        "coverage",
        "otherMaterial",
        "embargo",
        "resourcePackageArchive",
        "conceptualComponentOrConceptualComponentReference",
        "dataCollectionOrDataCollectionReference",
        "baseLogicalProductOrLogicalProductReference",
        "physicalDataProductOrPhysicalDataProductReference",
        "physicalInstanceOrPhysicalInstanceReference",
        "archiveOrArchiveReference",
        "ddiProfileOrDDIProfileReference",
        "comparisonOrComparisonReference",
        "organizationSchemeOrOrganizationSchemeReference",
        "conceptSchemeOrConceptSchemeReference",
        "universeSchemeOrUniverseSchemeReference",
        "conceptualVariableSchemeOrConceptualVariableSchemeReference",
        "representedVariableSchemeOrRepresentedVariableSchemeReference",
        "geographicStructureSchemeOrGeographicStructureSchemeReference",
        "geographicLocationSchemeOrGeographicLocationSchemeReference",
        "interviewerInstructionSchemeOrInterviewerInstructionSchemeReference",
        "controlConstructSchemeOrControlConstructSchemeReference",
        "questionSchemeOrQuestionSchemeReference",
        "categorySchemeOrCategorySchemeReference",
        "codeListSchemeOrCodeListSchemeReference",
        "nCubeSchemeOrNCubeSchemeReference",
        "variableSchemeOrVariableSchemeReference",
        "physicalStructureSchemeOrPhysicalStructureSchemeReference",
        "recordLayoutSchemeOrRecordLayoutSchemeReference",
        "qualityStatementSchemeOrQualityStatementSchemeReference",
        "instrumentSchemeOrInstrumentSchemeReference",
        "processingEventSchemeOrProcessingEventSchemeReference",
        "processingInstructionSchemeOrProcessingInstructionSchemeReference",
        "managedRepresentationSchemeOrManagedRepresentationSchemeReference"
})
public class ResourcePackageType
        extends MaintainableType {

    @XmlElement(name = "Citation", namespace = "ddi:reusable:3_2")
    protected CitationType citation;
    @XmlElement(name = "TypeOfResourcePackage")
    protected CodeValueType typeOfResourcePackage;
    @XmlElement(name = "Abstract", namespace = "ddi:reusable:3_2")
    protected StructuredStringType _abstract;
    @XmlElement(name = "AuthorizationSource", namespace = "ddi:reusable:3_2")
    protected List<AuthorizationSourceType> authorizationSource;
    @XmlElement(name = "UniverseReference", namespace = "ddi:reusable:3_2")
    protected ReferenceType universeReference;
    @XmlElement(name = "SeriesStatement", namespace = "ddi:reusable:3_2")
    protected List<SeriesStatementType> seriesStatement;
    @XmlElement(name = "QualityStatementReference", namespace = "ddi:reusable:3_2")
    protected List<ReferenceType> qualityStatementReference;
    @XmlElement(name = "FundingInformation", namespace = "ddi:reusable:3_2")
    protected List<FundingInformationType> fundingInformation;
    @XmlElement(name = "ProjectBudget")
    protected List<BudgetType> projectBudget;
    @XmlElement(name = "Purpose", namespace = "ddi:reusable:3_2")
    protected StructuredStringType purpose;
    @XmlElement(name = "Coverage", namespace = "ddi:reusable:3_2")
    protected CoverageType coverage;
    @XmlElement(name = "OtherMaterial", namespace = "ddi:reusable:3_2")
    protected List<OtherMaterialType> otherMaterial;
    @XmlElement(name = "Embargo", namespace = "ddi:reusable:3_2")
    protected List<EmbargoType> embargo;
    @XmlElement(name = "ResourcePackageArchive")
    protected List<ResourcePackageArchiveType> resourcePackageArchive;
    @XmlElements({
            @XmlElement(name = "ConceptualComponent", namespace = "ddi:conceptualcomponent:3_2", type = ConceptualComponentType.class),
            @XmlElement(name = "ConceptualComponentReference", namespace = "ddi:reusable:3_2", type = ReferenceType.class)
    })
    protected List<Object> conceptualComponentOrConceptualComponentReference;
    @XmlElements({
            @XmlElement(name = "DataCollection", namespace = "ddi:datacollection:3_2", type = DataCollectionType.class),
            @XmlElement(name = "DataCollectionReference", namespace = "ddi:reusable:3_2", type = ReferenceType.class)
    })
    protected List<Object> dataCollectionOrDataCollectionReference;
    @XmlElementRefs({
            @XmlElementRef(name = "LogicalProductReference", namespace = "ddi:reusable:3_2", type = JAXBElement.class, required = false),
            @XmlElementRef(name = "BaseLogicalProduct", namespace = "ddi:logicalproduct:3_2", type = JAXBElement.class, required = false)
    })
    protected List<JAXBElement<?>> baseLogicalProductOrLogicalProductReference;
    @XmlElements({
            @XmlElement(name = "PhysicalDataProduct", namespace = "ddi:physicaldataproduct:3_2", type = PhysicalDataProductType.class),
            @XmlElement(name = "PhysicalDataProductReference", namespace = "ddi:reusable:3_2", type = ReferenceType.class)
    })
    protected List<Object> physicalDataProductOrPhysicalDataProductReference;
    @XmlElements({
            @XmlElement(name = "PhysicalInstance", namespace = "ddi:physicalinstance:3_2", type = PhysicalInstanceType.class),
            @XmlElement(name = "PhysicalInstanceReference", namespace = "ddi:reusable:3_2", type = ReferenceType.class)
    })
    protected List<Object> physicalInstanceOrPhysicalInstanceReference;
    @XmlElements({
            @XmlElement(name = "Archive", namespace = "ddi:archive:3_2", type = ArchiveType.class),
            @XmlElement(name = "ArchiveReference", namespace = "ddi:reusable:3_2", type = ReferenceType.class)
    })
    protected List<Object> archiveOrArchiveReference;
    @XmlElements({
            @XmlElement(name = "DDIProfile", namespace = "ddi:ddiprofile:3_2", type = DDIProfileType.class),
            @XmlElement(name = "DDIProfileReference", namespace = "ddi:reusable:3_2", type = ReferenceType.class)
    })
    protected List<Object> ddiProfileOrDDIProfileReference;
    @XmlElements({
            @XmlElement(name = "Comparison", namespace = "ddi:comparative:3_2", type = ComparisonType.class),
            @XmlElement(name = "ComparisonReference", namespace = "ddi:reusable:3_2", type = ReferenceType.class)
    })
    protected List<Object> comparisonOrComparisonReference;
    @XmlElements({
            @XmlElement(name = "OrganizationScheme", namespace = "ddi:archive:3_2", type = OrganizationSchemeType.class),
            @XmlElement(name = "OrganizationSchemeReference", namespace = "ddi:reusable:3_2", type = SchemeReferenceType.class)
    })
    protected List<Object> organizationSchemeOrOrganizationSchemeReference;
    @XmlElements({
            @XmlElement(name = "ConceptScheme", namespace = "ddi:conceptualcomponent:3_2", type = ConceptSchemeType.class),
            @XmlElement(name = "ConceptSchemeReference", namespace = "ddi:reusable:3_2", type = SchemeReferenceType.class)
    })
    protected List<Object> conceptSchemeOrConceptSchemeReference;
    @XmlElements({
            @XmlElement(name = "UniverseScheme", namespace = "ddi:conceptualcomponent:3_2", type = UniverseSchemeType.class),
            @XmlElement(name = "UniverseSchemeReference", namespace = "ddi:reusable:3_2", type = SchemeReferenceType.class)
    })
    protected List<Object> universeSchemeOrUniverseSchemeReference;
    @XmlElements({
            @XmlElement(name = "ConceptualVariableScheme", namespace = "ddi:conceptualcomponent:3_2", type = ConceptualVariableSchemeType.class),
            @XmlElement(name = "ConceptualVariableSchemeReference", namespace = "ddi:reusable:3_2", type = SchemeReferenceType.class)
    })
    protected List<Object> conceptualVariableSchemeOrConceptualVariableSchemeReference;
    @XmlElements({
            @XmlElement(name = "RepresentedVariableScheme", namespace = "ddi:logicalproduct:3_2", type = RepresentedVariableSchemeType.class),
            @XmlElement(name = "RepresentedVariableSchemeReference", namespace = "ddi:reusable:3_2", type = SchemeReferenceType.class)
    })
    protected List<Object> representedVariableSchemeOrRepresentedVariableSchemeReference;
    @XmlElements({
            @XmlElement(name = "GeographicStructureScheme", namespace = "ddi:conceptualcomponent:3_2", type = GeographicStructureSchemeType.class),
            @XmlElement(name = "GeographicStructureSchemeReference", namespace = "ddi:reusable:3_2", type = SchemeReferenceType.class)
    })
    protected List<Object> geographicStructureSchemeOrGeographicStructureSchemeReference;
    @XmlElements({
            @XmlElement(name = "GeographicLocationScheme", namespace = "ddi:conceptualcomponent:3_2", type = GeographicLocationSchemeType.class),
            @XmlElement(name = "GeographicLocationSchemeReference", namespace = "ddi:reusable:3_2", type = SchemeReferenceType.class)
    })
    protected List<Object> geographicLocationSchemeOrGeographicLocationSchemeReference;
    @XmlElements({
            @XmlElement(name = "InterviewerInstructionScheme", namespace = "ddi:datacollection:3_2", type = InterviewerInstructionSchemeType.class),
            @XmlElement(name = "InterviewerInstructionSchemeReference", namespace = "ddi:reusable:3_2", type = SchemeReferenceType.class)
    })
    protected List<Object> interviewerInstructionSchemeOrInterviewerInstructionSchemeReference;
    @XmlElements({
            @XmlElement(name = "ControlConstructScheme", namespace = "ddi:datacollection:3_2", type = ControlConstructSchemeType.class),
            @XmlElement(name = "ControlConstructSchemeReference", namespace = "ddi:reusable:3_2", type = SchemeReferenceType.class)
    })
    protected List<Object> controlConstructSchemeOrControlConstructSchemeReference;
    @XmlElements({
            @XmlElement(name = "QuestionScheme", namespace = "ddi:datacollection:3_2", type = QuestionSchemeType.class),
            @XmlElement(name = "QuestionSchemeReference", namespace = "ddi:reusable:3_2", type = SchemeReferenceType.class)
    })
    protected List<Object> questionSchemeOrQuestionSchemeReference;
    @XmlElements({
            @XmlElement(name = "CategoryScheme", namespace = "ddi:logicalproduct:3_2", type = CategorySchemeType.class),
            @XmlElement(name = "CategorySchemeReference", namespace = "ddi:reusable:3_2", type = SchemeReferenceType.class)
    })
    protected List<Object> categorySchemeOrCategorySchemeReference;
    @XmlElements({
            @XmlElement(name = "CodeListScheme", namespace = "ddi:logicalproduct:3_2", type = CodeListSchemeType.class),
            @XmlElement(name = "CodeListSchemeReference", namespace = "ddi:reusable:3_2", type = SchemeReferenceType.class)
    })
    protected List<Object> codeListSchemeOrCodeListSchemeReference;
    @XmlElements({
            @XmlElement(name = "NCubeScheme", namespace = "ddi:logicalproduct:3_2", type = NCubeSchemeType.class),
            @XmlElement(name = "NCubeSchemeReference", namespace = "ddi:reusable:3_2", type = SchemeReferenceType.class)
    })
    protected List<Object> nCubeSchemeOrNCubeSchemeReference;
    @XmlElements({
            @XmlElement(name = "VariableScheme", namespace = "ddi:logicalproduct:3_2", type = VariableSchemeType.class),
            @XmlElement(name = "VariableSchemeReference", namespace = "ddi:reusable:3_2", type = SchemeReferenceType.class)
    })
    protected List<Object> variableSchemeOrVariableSchemeReference;
    @XmlElements({
            @XmlElement(name = "PhysicalStructureScheme", namespace = "ddi:physicaldataproduct:3_2", type = PhysicalStructureSchemeType.class),
            @XmlElement(name = "PhysicalStructureSchemeReference", namespace = "ddi:reusable:3_2", type = SchemeReferenceType.class)
    })
    protected List<Object> physicalStructureSchemeOrPhysicalStructureSchemeReference;
    @XmlElements({
            @XmlElement(name = "RecordLayoutScheme", namespace = "ddi:physicaldataproduct:3_2", type = RecordLayoutSchemeType.class),
            @XmlElement(name = "RecordLayoutSchemeReference", namespace = "ddi:reusable:3_2", type = SchemeReferenceType.class)
    })
    protected List<Object> recordLayoutSchemeOrRecordLayoutSchemeReference;
    @XmlElements({
            @XmlElement(name = "QualityStatementScheme", namespace = "ddi:reusable:3_2", type = QualityStatementSchemeType.class),
            @XmlElement(name = "QualityStatementSchemeReference", namespace = "ddi:reusable:3_2", type = SchemeReferenceType.class)
    })
    protected List<Object> qualityStatementSchemeOrQualityStatementSchemeReference;
    @XmlElements({
            @XmlElement(name = "InstrumentScheme", namespace = "ddi:datacollection:3_2", type = InstrumentSchemeType.class),
            @XmlElement(name = "InstrumentSchemeReference", namespace = "ddi:reusable:3_2", type = SchemeReferenceType.class)
    })
    protected List<Object> instrumentSchemeOrInstrumentSchemeReference;
    @XmlElements({
            @XmlElement(name = "ProcessingEventScheme", namespace = "ddi:datacollection:3_2", type = ProcessingEventSchemeType.class),
            @XmlElement(name = "ProcessingEventSchemeReference", namespace = "ddi:datacollection:3_2", type = SchemeReferenceType.class)
    })
    protected List<Object> processingEventSchemeOrProcessingEventSchemeReference;
    @XmlElements({
            @XmlElement(name = "ProcessingInstructionScheme", namespace = "ddi:datacollection:3_2", type = ProcessingInstructionSchemeType.class),
            @XmlElement(name = "ProcessingInstructionSchemeReference", namespace = "ddi:datacollection:3_2", type = SchemeReferenceType.class)
    })
    protected List<Object> processingInstructionSchemeOrProcessingInstructionSchemeReference;
    @XmlElements({
            @XmlElement(name = "ManagedRepresentationScheme", namespace = "ddi:reusable:3_2", type = ManagedRepresentationSchemeType.class),
            @XmlElement(name = "ManagedRepresentationSchemeReference", namespace = "ddi:reusable:3_2", type = SchemeReferenceType.class)
    })
    protected List<Object> managedRepresentationSchemeOrManagedRepresentationSchemeReference;

    /**
     * The citation for the ResourcePackage. DDI strongly recommends that at minimum a Title be provided.
     *
     * @return possible object is
     * {@link CitationType }
     */
    public CitationType getCitation() {
        return citation;
    }

    /**
     * Sets the value of the citation property.
     *
     * @param value allowed object is
     *              {@link CitationType }
     */
    public void setCitation(CitationType value) {
        this.citation = value;
    }

    /**
     * A brief description of the resource package type. Supports the use of a controlled vocabulary.
     *
     * @return possible object is
     * {@link CodeValueType }
     */
    public CodeValueType getTypeOfResourcePackage() {
        return typeOfResourcePackage;
    }

    /**
     * Sets the value of the typeOfResourcePackage property.
     *
     * @param value allowed object is
     *              {@link CodeValueType }
     */
    public void setTypeOfResourcePackage(CodeValueType value) {
        this.typeOfResourcePackage = value;
    }

    /**
     * An abstract of the ResourcePackage unit describing the nature and scope of the data collection, special characteristics of its content. Note that detailed information on the purpose of the ResourcePackage and structured coverage information are to be entered in Purpose and Coverage. Abstract supports multiple language versions of the same content as well as optional formatting of the content.
     *
     * @return possible object is
     * {@link StructuredStringType }
     */
    public StructuredStringType getAbstract() {
        return _abstract;
    }

    /**
     * Sets the value of the abstract property.
     *
     * @param value allowed object is
     *              {@link StructuredStringType }
     */
    public void setAbstract(StructuredStringType value) {
        this._abstract = value;
    }

    /**
     * Identifies the authorizing agency for the ResourcePackage and allows for the full text of the authorization (law, regulation, or other form of authorization). May be used to list authorizations from oversight committees and other regulatory agencies.Gets the value of the authorizationSource property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the authorizationSource property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getAuthorizationSource().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link AuthorizationSourceType }
     */
    public List<AuthorizationSourceType> getAuthorizationSource() {
        if (authorizationSource == null) {
            authorizationSource = new ArrayList<AuthorizationSourceType>();
        }
        return this.authorizationSource;
    }

    /**
     * Reference to the universe statement from the universe scheme, describing the ResourcePackage of persons or other elements that are the object of research and to which any analytic results refer. Age, nationality, and residence commonly help to delineate a given universe, but any of a number of factors may be involved, such as sex, race, income, veteran status, criminal convictions, etc. The universe may consist of elements other than persons, such as housing units, court cases, deaths, countries, etc. In general, it should be possible to tell from the description of the universe whether a given individual or element (hypothetical or real) is a member of the population under ResourcePackage. A universe may be described as "inclusive" or "exclusive". This ResourcePackage level reference is normally to the top level of the UniverseScheme.
     *
     * @return possible object is
     * {@link ReferenceType }
     */
    public ReferenceType getUniverseReference() {
        return universeReference;
    }

    /**
     * Sets the value of the universeReference property.
     *
     * @param value allowed object is
     *              {@link ReferenceType }
     */
    public void setUniverseReference(ReferenceType value) {
        this.universeReference = value;
    }

    /**
     * A ResourcePackage, particularly one in a series, may be the result of two series merging into a single ResourcePackage. The new ResourcePackage belongs to both series. For example, Niger now fields the UNICEF Multiple Indicators Cluster Survey (MICS) and the Demographic and Health Survey as a single merged instrument.Gets the value of the seriesStatement property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the seriesStatement property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSeriesStatement().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link SeriesStatementType }
     */
    public List<SeriesStatementType> getSeriesStatement() {
        if (seriesStatement == null) {
            seriesStatement = new ArrayList<SeriesStatementType>();
        }
        return this.seriesStatement;
    }

    /**
     * A reference to a QualityStatementScheme containing statements of quality related to the quality of the ResourcePackage methodology, metadata, or data. Quality statements may be related to external quality standards.Gets the value of the qualityStatementReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the qualityStatementReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getQualityStatementReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ReferenceType }
     */
    public List<ReferenceType> getQualityStatementReference() {
        if (qualityStatementReference == null) {
            qualityStatementReference = new ArrayList<ReferenceType>();
        }
        return this.qualityStatementReference;
    }

    /**
     * Contains details of the ResourcePackage unit's funding, including information about grants, agencies, etc.Gets the value of the fundingInformation property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the fundingInformation property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getFundingInformation().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link FundingInformationType }
     */
    public List<FundingInformationType> getFundingInformation() {
        if (fundingInformation == null) {
            fundingInformation = new ArrayList<FundingInformationType>();
        }
        return this.fundingInformation;
    }

    /**
     * This describes the overall budget of the ResourcePackage. It can be repeated for distinct budget activities. It contains a structured description and one or more budget documents described by an OtherMaterial type.Gets the value of the projectBudget property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the projectBudget property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getProjectBudget().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link BudgetType }
     */
    public List<BudgetType> getProjectBudget() {
        if (projectBudget == null) {
            projectBudget = new ArrayList<BudgetType>();
        }
        return this.projectBudget;
    }

    /**
     * The purpose of the ResourcePackage, why the ResourcePackage took place. This should include detailed information on the investigator's primary ResourcePackage questions or hypotheses as well as information on any legal basis for the data collection, such as laws requiring the collection of census data for apportionment purposes. Legal or other authorization should be provided in detail within AuthorizationSource. Purpose supports multiple language versions of the same content as well as optional formatting of the content.
     *
     * @return possible object is
     * {@link StructuredStringType }
     */
    public StructuredStringType getPurpose() {
        return purpose;
    }

    /**
     * Sets the value of the purpose property.
     *
     * @param value allowed object is
     *              {@link StructuredStringType }
     */
    public void setPurpose(StructuredStringType value) {
        this.purpose = value;
    }

    /**
     * Describes the coverage of the ResourcePackage unit. Detailed information on Topical, Temporal, and Spatial Coverage is contained here. Note that Coverage at this level should be inclusive all lower level modules or section. Lower level descriptions serve to constrain coverage within the scope described here.
     *
     * @return possible object is
     * {@link CoverageType }
     */
    public CoverageType getCoverage() {
        return coverage;
    }

    /**
     * Sets the value of the coverage property.
     *
     * @param value allowed object is
     *              {@link CoverageType }
     */
    public void setCoverage(CoverageType value) {
        this.coverage = value;
    }

    /**
     * Contains references to other materials relevant to the ResourcePackage unit, whether in DDI form or external. Links can be made from items in this section to any identifiable element in the instance. Best practice is to include OtherMaterial inside the maintainable containing the objects that are related to the OtherMaterial.Gets the value of the otherMaterial property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the otherMaterial property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getOtherMaterial().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link OtherMaterialType }
     */
    public List<OtherMaterialType> getOtherMaterial() {
        if (otherMaterial == null) {
            otherMaterial = new ArrayList<OtherMaterialType>();
        }
        return this.otherMaterial;
    }

    /**
     * Embargo information about the ResourcePackage unit. References to embargo information in this section can be made from individual variables.Gets the value of the embargo property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the embargo property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getEmbargo().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link EmbargoType }
     */
    public List<EmbargoType> getEmbargo() {
        if (embargo == null) {
            embargo = new ArrayList<EmbargoType>();
        }
        return this.embargo;
    }

    /**
     * This is archive information specific to the creation, maintenance, and archiving of the ResourcePackage provided either in-line or by reference. This packaging element differentiates this "Archive" from one being published as a product within a ResourcePackage.Gets the value of the resourcePackageArchive property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the resourcePackageArchive property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getResourcePackageArchive().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ResourcePackageArchiveType }
     */
    public List<ResourcePackageArchiveType> getResourcePackageArchive() {
        if (resourcePackageArchive == null) {
            resourcePackageArchive = new ArrayList<ResourcePackageArchiveType>();
        }
        return this.resourcePackageArchive;
    }

    /**
     * Gets the value of the conceptualComponentOrConceptualComponentReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the conceptualComponentOrConceptualComponentReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getConceptualComponentOrConceptualComponentReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ConceptualComponentType }
     * {@link ReferenceType }
     */
    public List<Object> getConceptualComponentOrConceptualComponentReference() {
        if (conceptualComponentOrConceptualComponentReference == null) {
            conceptualComponentOrConceptualComponentReference = new ArrayList<Object>();
        }
        return this.conceptualComponentOrConceptualComponentReference;
    }

    /**
     * Gets the value of the dataCollectionOrDataCollectionReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the dataCollectionOrDataCollectionReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDataCollectionOrDataCollectionReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link DataCollectionType }
     * {@link ReferenceType }
     */
    public List<Object> getDataCollectionOrDataCollectionReference() {
        if (dataCollectionOrDataCollectionReference == null) {
            dataCollectionOrDataCollectionReference = new ArrayList<Object>();
        }
        return this.dataCollectionOrDataCollectionReference;
    }

    /**
     * Gets the value of the baseLogicalProductOrLogicalProductReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the baseLogicalProductOrLogicalProductReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getBaseLogicalProductOrLogicalProductReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link JAXBElement }{@code <}{@link LogicalProductType }{@code >}
     * {@link JAXBElement }{@code <}{@link BaseLogicalProductType }{@code >}
     * {@link JAXBElement }{@code <}{@link ReferenceType }{@code >}
     */
    public List<JAXBElement<?>> getBaseLogicalProductOrLogicalProductReference() {
        if (baseLogicalProductOrLogicalProductReference == null) {
            baseLogicalProductOrLogicalProductReference = new ArrayList<JAXBElement<?>>();
        }
        return this.baseLogicalProductOrLogicalProductReference;
    }

    /**
     * Gets the value of the physicalDataProductOrPhysicalDataProductReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the physicalDataProductOrPhysicalDataProductReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPhysicalDataProductOrPhysicalDataProductReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link PhysicalDataProductType }
     * {@link ReferenceType }
     */
    public List<Object> getPhysicalDataProductOrPhysicalDataProductReference() {
        if (physicalDataProductOrPhysicalDataProductReference == null) {
            physicalDataProductOrPhysicalDataProductReference = new ArrayList<Object>();
        }
        return this.physicalDataProductOrPhysicalDataProductReference;
    }

    /**
     * Gets the value of the physicalInstanceOrPhysicalInstanceReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the physicalInstanceOrPhysicalInstanceReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPhysicalInstanceOrPhysicalInstanceReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link PhysicalInstanceType }
     * {@link ReferenceType }
     */
    public List<Object> getPhysicalInstanceOrPhysicalInstanceReference() {
        if (physicalInstanceOrPhysicalInstanceReference == null) {
            physicalInstanceOrPhysicalInstanceReference = new ArrayList<Object>();
        }
        return this.physicalInstanceOrPhysicalInstanceReference;
    }

    /**
     * Gets the value of the archiveOrArchiveReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the archiveOrArchiveReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getArchiveOrArchiveReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ArchiveType }
     * {@link ReferenceType }
     */
    public List<Object> getArchiveOrArchiveReference() {
        if (archiveOrArchiveReference == null) {
            archiveOrArchiveReference = new ArrayList<Object>();
        }
        return this.archiveOrArchiveReference;
    }

    /**
     * Gets the value of the ddiProfileOrDDIProfileReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the ddiProfileOrDDIProfileReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDDIProfileOrDDIProfileReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link DDIProfileType }
     * {@link ReferenceType }
     */
    public List<Object> getDDIProfileOrDDIProfileReference() {
        if (ddiProfileOrDDIProfileReference == null) {
            ddiProfileOrDDIProfileReference = new ArrayList<Object>();
        }
        return this.ddiProfileOrDDIProfileReference;
    }

    /**
     * Gets the value of the comparisonOrComparisonReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the comparisonOrComparisonReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getComparisonOrComparisonReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ComparisonType }
     * {@link ReferenceType }
     */
    public List<Object> getComparisonOrComparisonReference() {
        if (comparisonOrComparisonReference == null) {
            comparisonOrComparisonReference = new ArrayList<Object>();
        }
        return this.comparisonOrComparisonReference;
    }

    /**
     * Gets the value of the organizationSchemeOrOrganizationSchemeReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the organizationSchemeOrOrganizationSchemeReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getOrganizationSchemeOrOrganizationSchemeReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link OrganizationSchemeType }
     * {@link SchemeReferenceType }
     */
    public List<Object> getOrganizationSchemeOrOrganizationSchemeReference() {
        if (organizationSchemeOrOrganizationSchemeReference == null) {
            organizationSchemeOrOrganizationSchemeReference = new ArrayList<Object>();
        }
        return this.organizationSchemeOrOrganizationSchemeReference;
    }

    /**
     * Gets the value of the conceptSchemeOrConceptSchemeReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the conceptSchemeOrConceptSchemeReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getConceptSchemeOrConceptSchemeReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ConceptSchemeType }
     * {@link SchemeReferenceType }
     */
    public List<Object> getConceptSchemeOrConceptSchemeReference() {
        if (conceptSchemeOrConceptSchemeReference == null) {
            conceptSchemeOrConceptSchemeReference = new ArrayList<Object>();
        }
        return this.conceptSchemeOrConceptSchemeReference;
    }

    /**
     * Gets the value of the universeSchemeOrUniverseSchemeReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the universeSchemeOrUniverseSchemeReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getUniverseSchemeOrUniverseSchemeReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link UniverseSchemeType }
     * {@link SchemeReferenceType }
     */
    public List<Object> getUniverseSchemeOrUniverseSchemeReference() {
        if (universeSchemeOrUniverseSchemeReference == null) {
            universeSchemeOrUniverseSchemeReference = new ArrayList<Object>();
        }
        return this.universeSchemeOrUniverseSchemeReference;
    }

    /**
     * Gets the value of the conceptualVariableSchemeOrConceptualVariableSchemeReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the conceptualVariableSchemeOrConceptualVariableSchemeReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getConceptualVariableSchemeOrConceptualVariableSchemeReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ConceptualVariableSchemeType }
     * {@link SchemeReferenceType }
     */
    public List<Object> getConceptualVariableSchemeOrConceptualVariableSchemeReference() {
        if (conceptualVariableSchemeOrConceptualVariableSchemeReference == null) {
            conceptualVariableSchemeOrConceptualVariableSchemeReference = new ArrayList<Object>();
        }
        return this.conceptualVariableSchemeOrConceptualVariableSchemeReference;
    }

    /**
     * Gets the value of the representedVariableSchemeOrRepresentedVariableSchemeReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the representedVariableSchemeOrRepresentedVariableSchemeReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getRepresentedVariableSchemeOrRepresentedVariableSchemeReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RepresentedVariableSchemeType }
     * {@link SchemeReferenceType }
     */
    public List<Object> getRepresentedVariableSchemeOrRepresentedVariableSchemeReference() {
        if (representedVariableSchemeOrRepresentedVariableSchemeReference == null) {
            representedVariableSchemeOrRepresentedVariableSchemeReference = new ArrayList<Object>();
        }
        return this.representedVariableSchemeOrRepresentedVariableSchemeReference;
    }

    /**
     * Gets the value of the geographicStructureSchemeOrGeographicStructureSchemeReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the geographicStructureSchemeOrGeographicStructureSchemeReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getGeographicStructureSchemeOrGeographicStructureSchemeReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link GeographicStructureSchemeType }
     * {@link SchemeReferenceType }
     */
    public List<Object> getGeographicStructureSchemeOrGeographicStructureSchemeReference() {
        if (geographicStructureSchemeOrGeographicStructureSchemeReference == null) {
            geographicStructureSchemeOrGeographicStructureSchemeReference = new ArrayList<Object>();
        }
        return this.geographicStructureSchemeOrGeographicStructureSchemeReference;
    }

    /**
     * Gets the value of the geographicLocationSchemeOrGeographicLocationSchemeReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the geographicLocationSchemeOrGeographicLocationSchemeReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getGeographicLocationSchemeOrGeographicLocationSchemeReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link GeographicLocationSchemeType }
     * {@link SchemeReferenceType }
     */
    public List<Object> getGeographicLocationSchemeOrGeographicLocationSchemeReference() {
        if (geographicLocationSchemeOrGeographicLocationSchemeReference == null) {
            geographicLocationSchemeOrGeographicLocationSchemeReference = new ArrayList<Object>();
        }
        return this.geographicLocationSchemeOrGeographicLocationSchemeReference;
    }

    /**
     * Gets the value of the interviewerInstructionSchemeOrInterviewerInstructionSchemeReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the interviewerInstructionSchemeOrInterviewerInstructionSchemeReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getInterviewerInstructionSchemeOrInterviewerInstructionSchemeReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link InterviewerInstructionSchemeType }
     * {@link SchemeReferenceType }
     */
    public List<Object> getInterviewerInstructionSchemeOrInterviewerInstructionSchemeReference() {
        if (interviewerInstructionSchemeOrInterviewerInstructionSchemeReference == null) {
            interviewerInstructionSchemeOrInterviewerInstructionSchemeReference = new ArrayList<Object>();
        }
        return this.interviewerInstructionSchemeOrInterviewerInstructionSchemeReference;
    }

    /**
     * Gets the value of the controlConstructSchemeOrControlConstructSchemeReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the controlConstructSchemeOrControlConstructSchemeReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getControlConstructSchemeOrControlConstructSchemeReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ControlConstructSchemeType }
     * {@link SchemeReferenceType }
     */
    public List<Object> getControlConstructSchemeOrControlConstructSchemeReference() {
        if (controlConstructSchemeOrControlConstructSchemeReference == null) {
            controlConstructSchemeOrControlConstructSchemeReference = new ArrayList<Object>();
        }
        return this.controlConstructSchemeOrControlConstructSchemeReference;
    }

    /**
     * Gets the value of the questionSchemeOrQuestionSchemeReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the questionSchemeOrQuestionSchemeReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getQuestionSchemeOrQuestionSchemeReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link QuestionSchemeType }
     * {@link SchemeReferenceType }
     */
    public List<Object> getQuestionSchemeOrQuestionSchemeReference() {
        if (questionSchemeOrQuestionSchemeReference == null) {
            questionSchemeOrQuestionSchemeReference = new ArrayList<Object>();
        }
        return this.questionSchemeOrQuestionSchemeReference;
    }

    /**
     * Gets the value of the categorySchemeOrCategorySchemeReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the categorySchemeOrCategorySchemeReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCategorySchemeOrCategorySchemeReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CategorySchemeType }
     * {@link SchemeReferenceType }
     */
    public List<Object> getCategorySchemeOrCategorySchemeReference() {
        if (categorySchemeOrCategorySchemeReference == null) {
            categorySchemeOrCategorySchemeReference = new ArrayList<Object>();
        }
        return this.categorySchemeOrCategorySchemeReference;
    }

    /**
     * Gets the value of the codeListSchemeOrCodeListSchemeReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the codeListSchemeOrCodeListSchemeReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCodeListSchemeOrCodeListSchemeReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CodeListSchemeType }
     * {@link SchemeReferenceType }
     */
    public List<Object> getCodeListSchemeOrCodeListSchemeReference() {
        if (codeListSchemeOrCodeListSchemeReference == null) {
            codeListSchemeOrCodeListSchemeReference = new ArrayList<Object>();
        }
        return this.codeListSchemeOrCodeListSchemeReference;
    }

    /**
     * Gets the value of the nCubeSchemeOrNCubeSchemeReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the nCubeSchemeOrNCubeSchemeReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getNCubeSchemeOrNCubeSchemeReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link NCubeSchemeType }
     * {@link SchemeReferenceType }
     */
    public List<Object> getNCubeSchemeOrNCubeSchemeReference() {
        if (nCubeSchemeOrNCubeSchemeReference == null) {
            nCubeSchemeOrNCubeSchemeReference = new ArrayList<Object>();
        }
        return this.nCubeSchemeOrNCubeSchemeReference;
    }

    /**
     * Gets the value of the variableSchemeOrVariableSchemeReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the variableSchemeOrVariableSchemeReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getVariableSchemeOrVariableSchemeReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link VariableSchemeType }
     * {@link SchemeReferenceType }
     */
    public List<Object> getVariableSchemeOrVariableSchemeReference() {
        if (variableSchemeOrVariableSchemeReference == null) {
            variableSchemeOrVariableSchemeReference = new ArrayList<Object>();
        }
        return this.variableSchemeOrVariableSchemeReference;
    }

    /**
     * Gets the value of the physicalStructureSchemeOrPhysicalStructureSchemeReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the physicalStructureSchemeOrPhysicalStructureSchemeReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPhysicalStructureSchemeOrPhysicalStructureSchemeReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link PhysicalStructureSchemeType }
     * {@link SchemeReferenceType }
     */
    public List<Object> getPhysicalStructureSchemeOrPhysicalStructureSchemeReference() {
        if (physicalStructureSchemeOrPhysicalStructureSchemeReference == null) {
            physicalStructureSchemeOrPhysicalStructureSchemeReference = new ArrayList<Object>();
        }
        return this.physicalStructureSchemeOrPhysicalStructureSchemeReference;
    }

    /**
     * Gets the value of the recordLayoutSchemeOrRecordLayoutSchemeReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the recordLayoutSchemeOrRecordLayoutSchemeReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getRecordLayoutSchemeOrRecordLayoutSchemeReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RecordLayoutSchemeType }
     * {@link SchemeReferenceType }
     */
    public List<Object> getRecordLayoutSchemeOrRecordLayoutSchemeReference() {
        if (recordLayoutSchemeOrRecordLayoutSchemeReference == null) {
            recordLayoutSchemeOrRecordLayoutSchemeReference = new ArrayList<Object>();
        }
        return this.recordLayoutSchemeOrRecordLayoutSchemeReference;
    }

    /**
     * Gets the value of the qualityStatementSchemeOrQualityStatementSchemeReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the qualityStatementSchemeOrQualityStatementSchemeReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getQualityStatementSchemeOrQualityStatementSchemeReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link QualityStatementSchemeType }
     * {@link SchemeReferenceType }
     */
    public List<Object> getQualityStatementSchemeOrQualityStatementSchemeReference() {
        if (qualityStatementSchemeOrQualityStatementSchemeReference == null) {
            qualityStatementSchemeOrQualityStatementSchemeReference = new ArrayList<Object>();
        }
        return this.qualityStatementSchemeOrQualityStatementSchemeReference;
    }

    /**
     * Gets the value of the instrumentSchemeOrInstrumentSchemeReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the instrumentSchemeOrInstrumentSchemeReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getInstrumentSchemeOrInstrumentSchemeReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link InstrumentSchemeType }
     * {@link SchemeReferenceType }
     */
    public List<Object> getInstrumentSchemeOrInstrumentSchemeReference() {
        if (instrumentSchemeOrInstrumentSchemeReference == null) {
            instrumentSchemeOrInstrumentSchemeReference = new ArrayList<Object>();
        }
        return this.instrumentSchemeOrInstrumentSchemeReference;
    }

    /**
     * Gets the value of the processingEventSchemeOrProcessingEventSchemeReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the processingEventSchemeOrProcessingEventSchemeReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getProcessingEventSchemeOrProcessingEventSchemeReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ProcessingEventSchemeType }
     * {@link SchemeReferenceType }
     */
    public List<Object> getProcessingEventSchemeOrProcessingEventSchemeReference() {
        if (processingEventSchemeOrProcessingEventSchemeReference == null) {
            processingEventSchemeOrProcessingEventSchemeReference = new ArrayList<Object>();
        }
        return this.processingEventSchemeOrProcessingEventSchemeReference;
    }

    /**
     * Gets the value of the processingInstructionSchemeOrProcessingInstructionSchemeReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the processingInstructionSchemeOrProcessingInstructionSchemeReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getProcessingInstructionSchemeOrProcessingInstructionSchemeReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ProcessingInstructionSchemeType }
     * {@link SchemeReferenceType }
     */
    public List<Object> getProcessingInstructionSchemeOrProcessingInstructionSchemeReference() {
        if (processingInstructionSchemeOrProcessingInstructionSchemeReference == null) {
            processingInstructionSchemeOrProcessingInstructionSchemeReference = new ArrayList<Object>();
        }
        return this.processingInstructionSchemeOrProcessingInstructionSchemeReference;
    }

    /**
     * Gets the value of the managedRepresentationSchemeOrManagedRepresentationSchemeReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the managedRepresentationSchemeOrManagedRepresentationSchemeReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getManagedRepresentationSchemeOrManagedRepresentationSchemeReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ManagedRepresentationSchemeType }
     * {@link SchemeReferenceType }
     */
    public List<Object> getManagedRepresentationSchemeOrManagedRepresentationSchemeReference() {
        if (managedRepresentationSchemeOrManagedRepresentationSchemeReference == null) {
            managedRepresentationSchemeOrManagedRepresentationSchemeReference = new ArrayList<Object>();
        }
        return this.managedRepresentationSchemeOrManagedRepresentationSchemeReference;
    }

}

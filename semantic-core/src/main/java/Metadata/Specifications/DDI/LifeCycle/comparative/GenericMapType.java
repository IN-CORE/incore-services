//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.11 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2017.01.04 at 03:10:13 PM CST 
//


package Metadata.Specifications.DDI.LifeCycle.comparative;

import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;

import Metadata.Specifications.DDI.LifeCycle.reusable.LabelType;
import Metadata.Specifications.DDI.LifeCycle.reusable.NameType;
import Metadata.Specifications.DDI.LifeCycle.reusable.SchemeReferenceType;
import Metadata.Specifications.DDI.LifeCycle.reusable.StructuredStringType;
import Metadata.Specifications.DDI.LifeCycle.reusable.VersionableType;


/**
 * Maps the content of two different schemes of objects of the same type providing detail for the comparable items within those two schemes. Note that comparisons can be made between multiple items in the same scheme or two versions of the same scheme. In addition to the standard name, label, and description of the map, identifies the source scheme and target scheme containing those objects, describes the correspondence between the source and target schemes, and provides detailed comparison of the items within those two schemes.
 * <p>
 * <p>Java class for GenericMapType complex type.
 * <p>
 * <p>The following schema fragment specifies the expected content contained within this class.
 * <p>
 * <pre>
 * &lt;complexType name="GenericMapType"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{ddi:reusable:3_2}VersionableType"&gt;
 *       &lt;sequence&gt;
 *         &lt;element ref="{ddi:comparative:3_2}MapName" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}Label" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}Description" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:comparative:3_2}SourceSchemeReference"/&gt;
 *         &lt;element ref="{ddi:comparative:3_2}TargetSchemeReference"/&gt;
 *         &lt;element ref="{ddi:comparative:3_2}Correspondence" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:comparative:3_2}ItemMap" maxOccurs="unbounded" minOccurs="0"/&gt;
 *       &lt;/sequence&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "GenericMapType", propOrder = {
        "mapName",
        "label",
        "description",
        "sourceSchemeReference",
        "targetSchemeReference",
        "correspondence",
        "itemMap"
})
public class GenericMapType
        extends VersionableType {

    @XmlElement(name = "MapName")
    protected List<NameType> mapName;
    @XmlElement(name = "Label", namespace = "ddi:reusable:3_2")
    protected List<LabelType> label;
    @XmlElement(name = "Description", namespace = "ddi:reusable:3_2")
    protected StructuredStringType description;
    @XmlElement(name = "SourceSchemeReference", required = true)
    protected SchemeReferenceType sourceSchemeReference;
    @XmlElement(name = "TargetSchemeReference", required = true)
    protected SchemeReferenceType targetSchemeReference;
    @XmlElement(name = "Correspondence")
    protected CorrespondenceType correspondence;
    @XmlElement(name = "ItemMap")
    protected List<ItemMapType> itemMap;

    /**
     * A name for the Map. May be expressed in multiple languages. Repeat the element to express names with different content, for example different names for different systems.Gets the value of the mapName property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the mapName property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getMapName().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link NameType }
     */
    public List<NameType> getMapName() {
        if (mapName == null) {
            mapName = new ArrayList<NameType>();
        }
        return this.mapName;
    }

    /**
     * A display label for the Map. May be expressed in multiple languages. Repeat for labels with different content, for example, labels with differing length limitations.Gets the value of the label property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the label property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getLabel().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link LabelType }
     */
    public List<LabelType> getLabel() {
        if (label == null) {
            label = new ArrayList<LabelType>();
        }
        return this.label;
    }

    /**
     * A description of the content and purpose of the Map. May be expressed in multiple languages and supports the use of structured content.
     *
     * @return possible object is
     * {@link StructuredStringType }
     */
    public StructuredStringType getDescription() {
        return description;
    }

    /**
     * Sets the value of the description property.
     *
     * @param value allowed object is
     *              {@link StructuredStringType }
     */
    public void setDescription(StructuredStringType value) {
        this.description = value;
    }

    /**
     * Mappings are unidirectional. The scheme referenced as the source is the scheme contents that would be transformed into the scheme contents identified as the target scheme contents.
     *
     * @return possible object is
     * {@link SchemeReferenceType }
     */
    public SchemeReferenceType getSourceSchemeReference() {
        return sourceSchemeReference;
    }

    /**
     * Sets the value of the sourceSchemeReference property.
     *
     * @param value allowed object is
     *              {@link SchemeReferenceType }
     */
    public void setSourceSchemeReference(SchemeReferenceType value) {
        this.sourceSchemeReference = value;
    }

    /**
     * Reference to the scheme containing the target structure.
     *
     * @return possible object is
     * {@link SchemeReferenceType }
     */
    public SchemeReferenceType getTargetSchemeReference() {
        return targetSchemeReference;
    }

    /**
     * Sets the value of the targetSchemeReference property.
     *
     * @param value allowed object is
     *              {@link SchemeReferenceType }
     */
    public void setTargetSchemeReference(SchemeReferenceType value) {
        this.targetSchemeReference = value;
    }

    /**
     * Describe the level of similarity and difference between the Source and the Target schemes.
     *
     * @return possible object is
     * {@link CorrespondenceType }
     */
    public CorrespondenceType getCorrespondence() {
        return correspondence;
    }

    /**
     * Sets the value of the correspondence property.
     *
     * @param value allowed object is
     *              {@link CorrespondenceType }
     */
    public void setCorrespondence(CorrespondenceType value) {
        this.correspondence = value;
    }

    /**
     * Contains the mappings for individual items within the Source and Target schemes.Gets the value of the itemMap property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the itemMap property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getItemMap().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ItemMapType }
     */
    public List<ItemMapType> getItemMap() {
        if (itemMap == null) {
            itemMap = new ArrayList<ItemMapType>();
        }
        return this.itemMap;
    }

}

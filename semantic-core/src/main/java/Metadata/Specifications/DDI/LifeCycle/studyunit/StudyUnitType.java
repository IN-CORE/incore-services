//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.11 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2017.01.04 at 03:10:13 PM CST 
//


package Metadata.Specifications.DDI.LifeCycle.studyunit;

import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlElementRefs;
import javax.xml.bind.annotation.XmlElements;
import javax.xml.bind.annotation.XmlType;

import Metadata.Specifications.DDI.LifeCycle.archive.ArchiveType;
import Metadata.Specifications.DDI.LifeCycle.conceptualcomponent.ConceptualComponentType;
import Metadata.Specifications.DDI.LifeCycle.datacollection.DataCollectionType;
import Metadata.Specifications.DDI.LifeCycle.ddiprofile.DDIProfileType;
import Metadata.Specifications.DDI.LifeCycle.logicalproduct.BaseLogicalProductType;
import Metadata.Specifications.DDI.LifeCycle.logicalproduct.LogicalProductType;
import Metadata.Specifications.DDI.LifeCycle.physicaldataproduct.PhysicalDataProductType;
import Metadata.Specifications.DDI.LifeCycle.physicalinstance.PhysicalInstanceType;
import Metadata.Specifications.DDI.LifeCycle.reusable.AuthorizationSourceType;
import Metadata.Specifications.DDI.LifeCycle.reusable.BudgetType;
import Metadata.Specifications.DDI.LifeCycle.reusable.CitationType;
import Metadata.Specifications.DDI.LifeCycle.reusable.CodeValueType;
import Metadata.Specifications.DDI.LifeCycle.reusable.CoverageType;
import Metadata.Specifications.DDI.LifeCycle.reusable.EmbargoType;
import Metadata.Specifications.DDI.LifeCycle.reusable.ExPostEvaluationType;
import Metadata.Specifications.DDI.LifeCycle.reusable.FundingInformationType;
import Metadata.Specifications.DDI.LifeCycle.reusable.InternationalStringType;
import Metadata.Specifications.DDI.LifeCycle.reusable.KindOfDataType;
import Metadata.Specifications.DDI.LifeCycle.reusable.MaintainableType;
import Metadata.Specifications.DDI.LifeCycle.reusable.OtherMaterialType;
import Metadata.Specifications.DDI.LifeCycle.reusable.QualityStatementSchemeType;
import Metadata.Specifications.DDI.LifeCycle.reusable.ReferenceType;
import Metadata.Specifications.DDI.LifeCycle.reusable.RequiredResourcePackagesType;
import Metadata.Specifications.DDI.LifeCycle.reusable.SchemeReferenceType;
import Metadata.Specifications.DDI.LifeCycle.reusable.SeriesStatementType;
import Metadata.Specifications.DDI.LifeCycle.reusable.StructuredStringType;


/**
 * A primary packaging and publication module within DDI representing the purpose, background, development, data capture, and data products related to a study. In DDI a study is defined as a single coordinated set of data collection/capture activities, such as a one-time survey or a single iteration of a multi-year repeated study (such as one year of a longitudinal survey). The StudyUnit brings together all of the components of the study including the description of its purpose, funding, quality statements, data collection and capture methods and activities, processing activities, and a description of the resulting data (description of its intellectual or logical content plus a description of its physical store). A study unit may have only a single data collection or capture process resulting in one or more data products (i.e., Census). A complex study unit may contain multiple means of data capture that are integrated into one or more data products (i.e., a medical study collecting bio-markers, patient background, health care service information, etc.). A longitudinal study with multiple waves or iterations of data collection is considered to be a group of studies, each wave or iteration captured as a single study unit. As a primary packaging module, the Study Unit contains a full citation, abstract, authorization information, a universe reference, series statement, quality statement, information on post study evaluation, funding information, budget, purpose, coverage, type of analysis units covered, kind of data, other materials, a list of required resource packages, embargoes,  the conceptual components (universe, concept, data element, geographic structure and locations), data collection, logical products, physical data products, physical instance, archive, and DDI profile. The maintainable elements within a Study Unit may be included in-line or by reference.
 * <p>
 * <p>Java class for StudyUnitType complex type.
 * <p>
 * <p>The following schema fragment specifies the expected content contained within this class.
 * <p>
 * <pre>
 * &lt;complexType name="StudyUnitType"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{ddi:reusable:3_2}MaintainableType"&gt;
 *       &lt;sequence&gt;
 *         &lt;element ref="{ddi:reusable:3_2}Citation" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}Abstract" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}AuthorizationSource" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}UniverseReference" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}SeriesStatement" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}QualityStatementReference" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:reusable:3_2}QualityStatementScheme" maxOccurs="unbounded" minOccurs="0"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}QualityStatementSchemeReference" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;/choice&gt;
 *         &lt;element ref="{ddi:reusable:3_2}ExPostEvaluation" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}FundingInformation" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:studyunit:3_2}StudyBudget" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}Purpose" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}Coverage" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}AnalysisUnit" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}AnalysisUnitsCovered" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}KindOfData" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}OtherMaterial" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}RequiredResourcePackages" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}Embargo" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:conceptualcomponent:3_2}ConceptualComponent"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}ConceptualComponentReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:datacollection:3_2}DataCollection"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}DataCollectionReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:logicalproduct:3_2}BaseLogicalProduct"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}LogicalProductReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:physicaldataproduct:3_2}PhysicalDataProduct"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}PhysicalDataProductReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:physicalinstance:3_2}PhysicalInstance"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}PhysicalInstanceReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:archive:3_2}Archive"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}ArchiveReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:ddiprofile:3_2}DDIProfile"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}DDIProfileReference"/&gt;
 *         &lt;/choice&gt;
 *       &lt;/sequence&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "StudyUnitType", propOrder = {
        "citation",
        "_abstract",
        "authorizationSource",
        "universeReference",
        "seriesStatement",
        "qualityStatementReference",
        "qualityStatementSchemeOrQualityStatementSchemeReference",
        "exPostEvaluation",
        "fundingInformation",
        "studyBudget",
        "purpose",
        "coverage",
        "analysisUnit",
        "analysisUnitsCovered",
        "kindOfData",
        "otherMaterial",
        "requiredResourcePackages",
        "embargo",
        "conceptualComponentOrConceptualComponentReference",
        "dataCollectionOrDataCollectionReference",
        "baseLogicalProductOrLogicalProductReference",
        "physicalDataProductOrPhysicalDataProductReference",
        "physicalInstanceOrPhysicalInstanceReference",
        "archiveOrArchiveReference",
        "ddiProfileOrDDIProfileReference"
})
public class StudyUnitType extends MaintainableType {

    @XmlElement(name = "Citation", namespace = "ddi:reusable:3_2")
    protected CitationType citation;
    @XmlElement(name = "Abstract", namespace = "ddi:reusable:3_2")
    protected StructuredStringType _abstract;
    @XmlElement(name = "AuthorizationSource", namespace = "ddi:reusable:3_2")
    protected List<AuthorizationSourceType> authorizationSource;
    @XmlElement(name = "UniverseReference", namespace = "ddi:reusable:3_2")
    protected ReferenceType universeReference;
    @XmlElement(name = "SeriesStatement", namespace = "ddi:reusable:3_2")
    protected List<SeriesStatementType> seriesStatement;
    @XmlElement(name = "QualityStatementReference", namespace = "ddi:reusable:3_2")
    protected List<ReferenceType> qualityStatementReference;
    @XmlElements({
            @XmlElement(name = "QualityStatementScheme", namespace = "ddi:reusable:3_2", type = QualityStatementSchemeType.class),
            @XmlElement(name = "QualityStatementSchemeReference", namespace = "ddi:reusable:3_2", type = SchemeReferenceType.class)
    })
    protected List<Object> qualityStatementSchemeOrQualityStatementSchemeReference;
    @XmlElement(name = "ExPostEvaluation", namespace = "ddi:reusable:3_2")
    protected List<ExPostEvaluationType> exPostEvaluation;
    @XmlElement(name = "FundingInformation", namespace = "ddi:reusable:3_2")
    protected List<FundingInformationType> fundingInformation;
    @XmlElement(name = "StudyBudget")
    protected List<BudgetType> studyBudget;
    @XmlElement(name = "Purpose", namespace = "ddi:reusable:3_2")
    protected StructuredStringType purpose;
    @XmlElement(name = "Coverage", namespace = "ddi:reusable:3_2")
    protected CoverageType coverage;
    @XmlElement(name = "AnalysisUnit", namespace = "ddi:reusable:3_2")
    protected List<CodeValueType> analysisUnit;
    @XmlElement(name = "AnalysisUnitsCovered", namespace = "ddi:reusable:3_2")
    protected InternationalStringType analysisUnitsCovered;
    @XmlElement(name = "KindOfData", namespace = "ddi:reusable:3_2")
    protected List<KindOfDataType> kindOfData;
    @XmlElement(name = "OtherMaterial", namespace = "ddi:reusable:3_2")
    protected List<OtherMaterialType> otherMaterial;
    @XmlElement(name = "RequiredResourcePackages", namespace = "ddi:reusable:3_2")
    protected RequiredResourcePackagesType requiredResourcePackages;
    @XmlElement(name = "Embargo", namespace = "ddi:reusable:3_2")
    protected List<EmbargoType> embargo;
    @XmlElements({
            @XmlElement(name = "ConceptualComponent", namespace = "ddi:conceptualcomponent:3_2", type = ConceptualComponentType.class),
            @XmlElement(name = "ConceptualComponentReference", namespace = "ddi:reusable:3_2", type = ReferenceType.class)
    })
    protected List<Object> conceptualComponentOrConceptualComponentReference;
    @XmlElements({
            @XmlElement(name = "DataCollection", namespace = "ddi:datacollection:3_2", type = DataCollectionType.class),
            @XmlElement(name = "DataCollectionReference", namespace = "ddi:reusable:3_2", type = ReferenceType.class)
    })
    protected List<Object> dataCollectionOrDataCollectionReference;
    @XmlElementRefs({
            @XmlElementRef(name = "LogicalProductReference", namespace = "ddi:reusable:3_2", type = JAXBElement.class, required = false),
            @XmlElementRef(name = "BaseLogicalProduct", namespace = "ddi:logicalproduct:3_2", type = JAXBElement.class, required = false)
    })
    protected List<JAXBElement<?>> baseLogicalProductOrLogicalProductReference;
    @XmlElements({
            @XmlElement(name = "PhysicalDataProduct", namespace = "ddi:physicaldataproduct:3_2", type = PhysicalDataProductType.class),
            @XmlElement(name = "PhysicalDataProductReference", namespace = "ddi:reusable:3_2", type = ReferenceType.class)
    })
    protected List<Object> physicalDataProductOrPhysicalDataProductReference;
    @XmlElements({
            @XmlElement(name = "PhysicalInstance", namespace = "ddi:physicalinstance:3_2", type = PhysicalInstanceType.class),
            @XmlElement(name = "PhysicalInstanceReference", namespace = "ddi:reusable:3_2", type = ReferenceType.class)
    })
    protected List<Object> physicalInstanceOrPhysicalInstanceReference;
    @XmlElements({
            @XmlElement(name = "Archive", namespace = "ddi:archive:3_2", type = ArchiveType.class),
            @XmlElement(name = "ArchiveReference", namespace = "ddi:reusable:3_2", type = ReferenceType.class)
    })
    protected List<Object> archiveOrArchiveReference;
    @XmlElements({
            @XmlElement(name = "DDIProfile", namespace = "ddi:ddiprofile:3_2", type = DDIProfileType.class),
            @XmlElement(name = "DDIProfileReference", namespace = "ddi:reusable:3_2", type = ReferenceType.class)
    })
    protected List<Object> ddiProfileOrDDIProfileReference;

    /**
     * The citation for the study. DDI strongly recommends that at minimum a Title be provided.
     *
     * @return possible object is
     * {@link CitationType }
     */
    public CitationType getCitation() {
        return citation;
    }

    /**
     * Sets the value of the citation property.
     *
     * @param value allowed object is
     *              {@link CitationType }
     */
    public void setCitation(CitationType value) {
        this.citation = value;
    }

    /**
     * An abstract of the study unit describing the nature and scope of the data collection, special characteristics of its content. Note that detailed information on the purpose of the study and structured coverage information are to be entered in Purpose and Coverage. Abstract supports multiple language versions of the same content as well as optional formatting of the content.
     *
     * @return possible object is
     * {@link StructuredStringType }
     */
    public StructuredStringType getAbstract() {
        return _abstract;
    }

    /**
     * Sets the value of the abstract property.
     *
     * @param value allowed object is
     *              {@link StructuredStringType }
     */
    public void setAbstract(StructuredStringType value) {
        this._abstract = value;
    }

    /**
     * Identifies the authorizing agency for the study and allows for the full text of the authorization (law, regulation, or other form of authorization). May be used to list authorizations from oversight committees and other regulatory agencies.Gets the value of the authorizationSource property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the authorizationSource property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getAuthorizationSource().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link AuthorizationSourceType }
     */
    public List<AuthorizationSourceType> getAuthorizationSource() {
        if (authorizationSource == null) {
            authorizationSource = new ArrayList<AuthorizationSourceType>();
        }
        return this.authorizationSource;
    }

    /**
     * Reference to the universe statement from the universe scheme, describing the group of persons or other elements that are the object of research and to which any analytic results refer. Age, nationality, and residence commonly help to delineate a given universe, but any of a number of factors may be involved, such as sex, race, income, veteran status, criminal convictions, etc. The universe may consist of elements other than persons, such as housing units, court cases, deaths, countries, etc. In general, it should be possible to tell from the description of the universe whether a given individual or element (hypothetical or real) is a member of the population under study. A universe may be described as "inclusive" or "exclusive". This StudyUnit level reference is normally to the top level of the UniverseScheme.
     *
     * @return possible object is
     * {@link ReferenceType }
     */
    public ReferenceType getUniverseReference() {
        return universeReference;
    }

    /**
     * Sets the value of the universeReference property.
     *
     * @param value allowed object is
     *              {@link ReferenceType }
     */
    public void setUniverseReference(ReferenceType value) {
        this.universeReference = value;
    }

    /**
     * A study, particularly one in a series, may be the result of two series merging into a single study. The new study belongs to both series. For example, Niger now fields the UNICEF Multiple Indicators Cluster Survey (MICS) and the Demographic and Health Survey as a single merged instrument.Gets the value of the seriesStatement property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the seriesStatement property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSeriesStatement().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link SeriesStatementType }
     */
    public List<SeriesStatementType> getSeriesStatement() {
        if (seriesStatement == null) {
            seriesStatement = new ArrayList<SeriesStatementType>();
        }
        return this.seriesStatement;
    }

    /**
     * A reference to a Quality Statement pertaining to the quality of the study overall, metadata, or data to which it is associated. Quality statements may be related to external quality standards.Gets the value of the qualityStatementReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the qualityStatementReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getQualityStatementReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ReferenceType }
     */
    public List<ReferenceType> getQualityStatementReference() {
        if (qualityStatementReference == null) {
            qualityStatementReference = new ArrayList<ReferenceType>();
        }
        return this.qualityStatementReference;
    }

    /**
     * Gets the value of the qualityStatementSchemeOrQualityStatementSchemeReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the qualityStatementSchemeOrQualityStatementSchemeReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getQualityStatementSchemeOrQualityStatementSchemeReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link QualityStatementSchemeType }
     * {@link SchemeReferenceType }
     */
    public List<Object> getQualityStatementSchemeOrQualityStatementSchemeReference() {
        if (qualityStatementSchemeOrQualityStatementSchemeReference == null) {
            qualityStatementSchemeOrQualityStatementSchemeReference = new ArrayList<Object>();
        }
        return this.qualityStatementSchemeOrQualityStatementSchemeReference;
    }

    /**
     * An evaluation of the study process, often taking place after the completion of the study. These may include issues such as timing of the study, sequencing issues, cost/budget issues, relevance, institutional or legal arrangements etc. of the study. If the study is part of a series or group (i.e., a single wave in a longitudinal study) this may include evaluation of earlier waves which resulted in changes to the current wave.Gets the value of the exPostEvaluation property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the exPostEvaluation property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getExPostEvaluation().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ExPostEvaluationType }
     */
    public List<ExPostEvaluationType> getExPostEvaluation() {
        if (exPostEvaluation == null) {
            exPostEvaluation = new ArrayList<ExPostEvaluationType>();
        }
        return this.exPostEvaluation;
    }

    /**
     * Contains details of the study unit's funding, including information about grants, agencies, etc.Gets the value of the fundingInformation property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the fundingInformation property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getFundingInformation().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link FundingInformationType }
     */
    public List<FundingInformationType> getFundingInformation() {
        if (fundingInformation == null) {
            fundingInformation = new ArrayList<FundingInformationType>();
        }
        return this.fundingInformation;
    }

    /**
     * This describes the overall budget of the study. It can be repeated for distinct budget activities. It contains a structured description and one or more budget documents described by an OtherMaterial type.Gets the value of the studyBudget property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the studyBudget property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getStudyBudget().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link BudgetType }
     */
    public List<BudgetType> getStudyBudget() {
        if (studyBudget == null) {
            studyBudget = new ArrayList<BudgetType>();
        }
        return this.studyBudget;
    }

    /**
     * The purpose of the study, why the study took place. This should include detailed information on the investigator's primary study questions or hypotheses as well as information on any legal basis for the data collection, such as laws requiring the collection of census data for apportionment purposes. Legal or other authorization should be provided in detail within AuthorizationSource. Purpose supports multiple language versions of the same content as well as optional formatting of the content.
     *
     * @return possible object is
     * {@link StructuredStringType }
     */
    public StructuredStringType getPurpose() {
        return purpose;
    }

    /**
     * Sets the value of the purpose property.
     *
     * @param value allowed object is
     *              {@link StructuredStringType }
     */
    public void setPurpose(StructuredStringType value) {
        this.purpose = value;
    }

    /**
     * Describes the coverage of the study unit. Detailed information on Topical, Temporal, and Spatial Coverage is contained here. Note that Coverage at this level should be inclusive all lower level modules or section. Lower level descriptions serve to constrain coverage within the scope described here.
     *
     * @return possible object is
     * {@link CoverageType }
     */
    public CoverageType getCoverage() {
        return coverage;
    }

    /**
     * Sets the value of the coverage property.
     *
     * @param value allowed object is
     *              {@link CoverageType }
     */
    public void setCoverage(CoverageType value) {
        this.coverage = value;
    }

    /**
     * Allows the use of a controlled vocabulary to list all of the units of analysis used in the study. Should be repeated to describe multiple units of analysis.Gets the value of the analysisUnit property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the analysisUnit property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getAnalysisUnit().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CodeValueType }
     */
    public List<CodeValueType> getAnalysisUnit() {
        if (analysisUnit == null) {
            analysisUnit = new ArrayList<CodeValueType>();
        }
        return this.analysisUnit;
    }

    /**
     * A narrative of the units of analysis in the study unit. Uses an InternationalString to support multiple languages.
     *
     * @return possible object is
     * {@link InternationalStringType }
     */
    public InternationalStringType getAnalysisUnitsCovered() {
        return analysisUnitsCovered;
    }

    /**
     * Sets the value of the analysisUnitsCovered property.
     *
     * @param value allowed object is
     *              {@link InternationalStringType }
     */
    public void setAnalysisUnitsCovered(InternationalStringType value) {
        this.analysisUnitsCovered = value;
    }

    /**
     * Briefly describes the kind of data documented in the logical product(s) of a study unit. Examples include survey data, census/enumeration data, administrative data, measurement data, assessment data, demographic data, voting data, etc. Supports the use of an external controlled vocabulary.Gets the value of the kindOfData property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the kindOfData property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getKindOfData().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link KindOfDataType }
     */
    public List<KindOfDataType> getKindOfData() {
        if (kindOfData == null) {
            kindOfData = new ArrayList<KindOfDataType>();
        }
        return this.kindOfData;
    }

    /**
     * Contains references to other materials relevant to the study unit, whether in DDI form or external. Links can be made from items in this section to any identifiable element in the instance. Best practice is to include OtherMaterial inside the maintainable containing the objects that are related to the OtherMaterial.Gets the value of the otherMaterial property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the otherMaterial property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getOtherMaterial().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link OtherMaterialType }
     */
    public List<OtherMaterialType> getOtherMaterial() {
        if (otherMaterial == null) {
            otherMaterial = new ArrayList<OtherMaterialType>();
        }
        return this.otherMaterial;
    }

    /**
     * Specifies by reference the ResourcePackages required to resolve the Study. This list is informational and assists in creating full transmissions of metadata or creating archival packages. Primarily used after the instance is relatively stable and published.
     *
     * @return possible object is
     * {@link RequiredResourcePackagesType }
     */
    public RequiredResourcePackagesType getRequiredResourcePackages() {
        return requiredResourcePackages;
    }

    /**
     * Sets the value of the requiredResourcePackages property.
     *
     * @param value allowed object is
     *              {@link RequiredResourcePackagesType }
     */
    public void setRequiredResourcePackages(RequiredResourcePackagesType value) {
        this.requiredResourcePackages = value;
    }

    /**
     * Embargo information about the study unit. References to embargo information in this section can be made from individual variables.Gets the value of the embargo property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the embargo property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getEmbargo().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link EmbargoType }
     */
    public List<EmbargoType> getEmbargo() {
        if (embargo == null) {
            embargo = new ArrayList<EmbargoType>();
        }
        return this.embargo;
    }

    /**
     * Gets the value of the conceptualComponentOrConceptualComponentReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the conceptualComponentOrConceptualComponentReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getConceptualComponentOrConceptualComponentReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ConceptualComponentType }
     * {@link ReferenceType }
     */
    public List<Object> getConceptualComponentOrConceptualComponentReference() {
        if (conceptualComponentOrConceptualComponentReference == null) {
            conceptualComponentOrConceptualComponentReference = new ArrayList<Object>();
        }
        return this.conceptualComponentOrConceptualComponentReference;
    }

    /**
     * Gets the value of the dataCollectionOrDataCollectionReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the dataCollectionOrDataCollectionReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDataCollectionOrDataCollectionReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link DataCollectionType }
     * {@link ReferenceType }
     */
    public List<Object> getDataCollectionOrDataCollectionReference() {
        if (dataCollectionOrDataCollectionReference == null) {
            dataCollectionOrDataCollectionReference = new ArrayList<Object>();
        }
        return this.dataCollectionOrDataCollectionReference;
    }

    /**
     * Gets the value of the baseLogicalProductOrLogicalProductReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the baseLogicalProductOrLogicalProductReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getBaseLogicalProductOrLogicalProductReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link JAXBElement }{@code <}{@link LogicalProductType }{@code >}
     * {@link JAXBElement }{@code <}{@link BaseLogicalProductType }{@code >}
     * {@link JAXBElement }{@code <}{@link ReferenceType }{@code >}
     */
    public List<JAXBElement<?>> getBaseLogicalProductOrLogicalProductReference() {
        if (baseLogicalProductOrLogicalProductReference == null) {
            baseLogicalProductOrLogicalProductReference = new ArrayList<JAXBElement<?>>();
        }
        return this.baseLogicalProductOrLogicalProductReference;
    }

    /**
     * Gets the value of the physicalDataProductOrPhysicalDataProductReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the physicalDataProductOrPhysicalDataProductReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPhysicalDataProductOrPhysicalDataProductReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link PhysicalDataProductType }
     * {@link ReferenceType }
     */
    public List<Object> getPhysicalDataProductOrPhysicalDataProductReference() {
        if (physicalDataProductOrPhysicalDataProductReference == null) {
            physicalDataProductOrPhysicalDataProductReference = new ArrayList<Object>();
        }
        return this.physicalDataProductOrPhysicalDataProductReference;
    }

    /**
     * Gets the value of the physicalInstanceOrPhysicalInstanceReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the physicalInstanceOrPhysicalInstanceReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPhysicalInstanceOrPhysicalInstanceReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link PhysicalInstanceType }
     * {@link ReferenceType }
     */
    public List<Object> getPhysicalInstanceOrPhysicalInstanceReference() {
        if (physicalInstanceOrPhysicalInstanceReference == null) {
            physicalInstanceOrPhysicalInstanceReference = new ArrayList<Object>();
        }
        return this.physicalInstanceOrPhysicalInstanceReference;
    }

    /**
     * Gets the value of the archiveOrArchiveReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the archiveOrArchiveReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getArchiveOrArchiveReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ArchiveType }
     * {@link ReferenceType }
     */
    public List<Object> getArchiveOrArchiveReference() {
        if (archiveOrArchiveReference == null) {
            archiveOrArchiveReference = new ArrayList<Object>();
        }
        return this.archiveOrArchiveReference;
    }

    /**
     * Gets the value of the ddiProfileOrDDIProfileReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the ddiProfileOrDDIProfileReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDDIProfileOrDDIProfileReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link DDIProfileType }
     * {@link ReferenceType }
     */
    public List<Object> getDDIProfileOrDDIProfileReference() {
        if (ddiProfileOrDDIProfileReference == null) {
            ddiProfileOrDDIProfileReference = new ArrayList<Object>();
        }
        return this.ddiProfileOrDDIProfileReference;
    }

}

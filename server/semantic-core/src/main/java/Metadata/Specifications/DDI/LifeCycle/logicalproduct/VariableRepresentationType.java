//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.11 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2017.01.04 at 03:10:13 PM CST 
//


package Metadata.Specifications.DDI.LifeCycle.logicalproduct;

import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlType;

import Metadata.Specifications.DDI.LifeCycle.reusable.CodeRepresentationBaseType;
import Metadata.Specifications.DDI.LifeCycle.reusable.CodeValueType;
import Metadata.Specifications.DDI.LifeCycle.reusable.ContentDateOffsetType;
import Metadata.Specifications.DDI.LifeCycle.reusable.DateTimeRepresentationBaseType;
import Metadata.Specifications.DDI.LifeCycle.reusable.ExternalCategoryRepresentationBaseType;
import Metadata.Specifications.DDI.LifeCycle.reusable.GeographicLocationCodeRepresentationBaseType;
import Metadata.Specifications.DDI.LifeCycle.reusable.GeographicStructureCodeRepresentationBaseType;
import Metadata.Specifications.DDI.LifeCycle.reusable.NumericRepresentationBaseType;
import Metadata.Specifications.DDI.LifeCycle.reusable.ProcessingInstructionReferenceType;
import Metadata.Specifications.DDI.LifeCycle.reusable.ReferenceType;
import Metadata.Specifications.DDI.LifeCycle.reusable.RepresentationReferenceType;
import Metadata.Specifications.DDI.LifeCycle.reusable.RepresentationType;
import Metadata.Specifications.DDI.LifeCycle.reusable.ScaleRepresentationBaseType;
import Metadata.Specifications.DDI.LifeCycle.reusable.TextRepresentationBaseType;


/**
 * Describes the representation of the variable in the data set. Describes the function of the variable, variables or standard weights that may be used to weight this variable during analysis, imputation and processing information, other variables used to create the value of this variable through concatenation, valid value representations (valid for analysis of respondents), missing value representations, aggregation methods used to generate the content of the variable, and additivity information.
 * <p>
 * <p>Java class for VariableRepresentationType complex type.
 * <p>
 * <p>The following schema fragment specifies the expected content contained within this class.
 * <p>
 * <pre>
 * &lt;complexType name="VariableRepresentationType"&gt;
 *   &lt;complexContent&gt;
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *       &lt;sequence&gt;
 *         &lt;element ref="{ddi:logicalproduct:3_2}VariableRole" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}WeightVariableReference" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:logicalproduct:3_2}StandardWeightReference" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:logicalproduct:3_2}ImputationReference" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:logicalproduct:3_2}ConcatenatedValue" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}ProcessingInstructionReference" minOccurs="0"/&gt;
 *         &lt;choice minOccurs="0"&gt;
 *           &lt;element ref="{ddi:reusable:3_2}ValueRepresentation"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}ValueRepresentationReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;element ref="{ddi:logicalproduct:3_2}MissingValuesReference" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}MeasurementUnit" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}ContentDateOffset" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}AggregationMethod" minOccurs="0"/&gt;
 *       &lt;/sequence&gt;
 *       &lt;attribute name="additivity" type="{ddi:logicalproduct:3_2}AdditivityCodeType" /&gt;
 *     &lt;/restriction&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "VariableRepresentationType", propOrder = {
        "variableRole",
        "weightVariableReference",
        "standardWeightReference",
        "imputationReference",
        "concatenatedValue",
        "processingInstructionReference",
        "valueRepresentation",
        "valueRepresentationReference",
        "missingValuesReference",
        "measurementUnit",
        "contentDateOffset",
        "aggregationMethod"
})
public class VariableRepresentationType {

    @XmlElement(name = "VariableRole")
    protected CodeValueType variableRole;
    @XmlElement(name = "WeightVariableReference", namespace = "ddi:reusable:3_2")
    protected List<ReferenceType> weightVariableReference;
    @XmlElement(name = "StandardWeightReference")
    protected ReferenceType standardWeightReference;
    @XmlElement(name = "ImputationReference")
    protected ReferenceType imputationReference;
    @XmlElement(name = "ConcatenatedValue")
    protected ConcatenatedValueType concatenatedValue;
    @XmlElement(name = "ProcessingInstructionReference", namespace = "ddi:reusable:3_2")
    protected ProcessingInstructionReferenceType processingInstructionReference;
    @XmlElementRef(name = "ValueRepresentation", namespace = "ddi:reusable:3_2", type = JAXBElement.class, required = false)
    protected JAXBElement<? extends RepresentationType> valueRepresentation;
    @XmlElementRef(name = "ValueRepresentationReference", namespace = "ddi:reusable:3_2", type = JAXBElement.class, required = false)
    protected JAXBElement<RepresentationReferenceType> valueRepresentationReference;
    @XmlElement(name = "MissingValuesReference")
    protected ReferenceType missingValuesReference;
    @XmlElement(name = "MeasurementUnit", namespace = "ddi:reusable:3_2")
    protected CodeValueType measurementUnit;
    @XmlElement(name = "ContentDateOffset", namespace = "ddi:reusable:3_2")
    protected ContentDateOffsetType contentDateOffset;
    @XmlElement(name = "AggregationMethod", namespace = "ddi:reusable:3_2")
    protected CodeValueType aggregationMethod;
    @XmlAttribute(name = "additivity")
    protected AdditivityCodeType additivity;

    /**
     * Describes a specific function of the variable, such as identity, weight, geographic variable, time, date, currency, etc. This is a more extensive means of identifying the function of the variable than the Boolean indicators on the variable. Allows for agency specific designations. Supports the use of a controlled vocabulary.
     *
     * @return possible object is
     * {@link CodeValueType }
     */
    public CodeValueType getVariableRole() {
        return variableRole;
    }

    /**
     * Sets the value of the variableRole property.
     *
     * @param value allowed object is
     *              {@link CodeValueType }
     */
    public void setVariableRole(CodeValueType value) {
        this.variableRole = value;
    }

    /**
     * Reference to one or more weight variables that may be used in analyzing this variable.Gets the value of the weightVariableReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the weightVariableReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getWeightVariableReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ReferenceType }
     */
    public List<ReferenceType> getWeightVariableReference() {
        if (weightVariableReference == null) {
            weightVariableReference = new ArrayList<ReferenceType>();
        }
        return this.weightVariableReference;
    }

    /**
     * Reference to the StandardWeight found in the Weighting description, which is relevant for analyzing this variable. A standard weight is a single weight used for all variables of a specific type or for a specified sub-universe.
     *
     * @return possible object is
     * {@link ReferenceType }
     */
    public ReferenceType getStandardWeightReference() {
        return standardWeightReference;
    }

    /**
     * Sets the value of the standardWeightReference property.
     *
     * @param value allowed object is
     *              {@link ReferenceType }
     */
    public void setStandardWeightReference(ReferenceType value) {
        this.standardWeightReference = value;
    }

    /**
     * Reference to the imputation process described as a General Instruction in a ProcessingInstructionScheme.
     *
     * @return possible object is
     * {@link ReferenceType }
     */
    public ReferenceType getImputationReference() {
        return imputationReference;
    }

    /**
     * Sets the value of the imputationReference property.
     *
     * @param value allowed object is
     *              {@link ReferenceType }
     */
    public void setImputationReference(ReferenceType value) {
        this.imputationReference = value;
    }

    /**
     * Provides a reference to other variables and describes the method for deriving the value of this variable by concatenating a collection of other variables. This is useful in creating concatenated keys.
     *
     * @return possible object is
     * {@link ConcatenatedValueType }
     */
    public ConcatenatedValueType getConcatenatedValue() {
        return concatenatedValue;
    }

    /**
     * Sets the value of the concatenatedValue property.
     *
     * @param value allowed object is
     *              {@link ConcatenatedValueType }
     */
    public void setConcatenatedValue(ConcatenatedValueType value) {
        this.concatenatedValue = value;
    }

    /**
     * A reference to either a general or generation instruction that was provided to those who converted information from one form to another to create a particular variable. This might include the reordering of numeric information into another form or the conversion of textual information into numeric information.
     *
     * @return possible object is
     * {@link ProcessingInstructionReferenceType }
     */
    public ProcessingInstructionReferenceType getProcessingInstructionReference() {
        return processingInstructionReference;
    }

    /**
     * Sets the value of the processingInstructionReference property.
     *
     * @param value allowed object is
     *              {@link ProcessingInstructionReferenceType }
     */
    public void setProcessingInstructionReference(ProcessingInstructionReferenceType value) {
        this.processingInstructionReference = value;
    }

    /**
     * Describes the actual representation of the variables' values. Allows for the listing of values to be treated as missing in order to support 3.1 structures. The preferred method is the use of a reference to ManagedMissingValues description using MissingValuesReference. If both are used and there is a conflict in the content, MissingValuesReference will override the content provided in the ValueRepresentationReference.
     *
     * @return possible object is
     * {@link JAXBElement }{@code <}{@link GeographicStructureCodeRepresentationBaseType }{@code >}
     * {@link JAXBElement }{@code <}{@link ScaleRepresentationBaseType }{@code >}
     * {@link JAXBElement }{@code <}{@link TextRepresentationBaseType }{@code >}
     * {@link JAXBElement }{@code <}{@link GeographicLocationCodeRepresentationBaseType }{@code >}
     * {@link JAXBElement }{@code <}{@link CodeRepresentationBaseType }{@code >}
     * {@link JAXBElement }{@code <}{@link ExternalCategoryRepresentationBaseType }{@code >}
     * {@link JAXBElement }{@code <}{@link DateTimeRepresentationBaseType }{@code >}
     * {@link JAXBElement }{@code <}{@link NumericRepresentationBaseType }{@code >}
     * {@link JAXBElement }{@code <}{@link RepresentationType }{@code >}
     */
    public JAXBElement<? extends RepresentationType> getValueRepresentation() {
        return valueRepresentation;
    }

    /**
     * Sets the value of the valueRepresentation property.
     *
     * @param value allowed object is
     *              {@link JAXBElement }{@code <}{@link GeographicStructureCodeRepresentationBaseType }{@code >}
     *              {@link JAXBElement }{@code <}{@link ScaleRepresentationBaseType }{@code >}
     *              {@link JAXBElement }{@code <}{@link TextRepresentationBaseType }{@code >}
     *              {@link JAXBElement }{@code <}{@link GeographicLocationCodeRepresentationBaseType }{@code >}
     *              {@link JAXBElement }{@code <}{@link CodeRepresentationBaseType }{@code >}
     *              {@link JAXBElement }{@code <}{@link ExternalCategoryRepresentationBaseType }{@code >}
     *              {@link JAXBElement }{@code <}{@link DateTimeRepresentationBaseType }{@code >}
     *              {@link JAXBElement }{@code <}{@link NumericRepresentationBaseType }{@code >}
     *              {@link JAXBElement }{@code <}{@link RepresentationType }{@code >}
     */
    public void setValueRepresentation(JAXBElement<? extends RepresentationType> value) {
        this.valueRepresentation = value;
    }

    /**
     * Allows for the use of a ManagedRepresentation by reference. ValueRepresentationReference is the abstract head of a substitution group and may be replaced with any valid substitution for ValueRepresentationReference.
     *
     * @return possible object is
     * {@link JAXBElement }{@code <}{@link RepresentationReferenceType }{@code >}
     * {@link JAXBElement }{@code <}{@link RepresentationReferenceType }{@code >}
     * {@link JAXBElement }{@code <}{@link RepresentationReferenceType }{@code >}
     * {@link JAXBElement }{@code <}{@link RepresentationReferenceType }{@code >}
     * {@link JAXBElement }{@code <}{@link RepresentationReferenceType }{@code >}
     */
    public JAXBElement<RepresentationReferenceType> getValueRepresentationReference() {
        return valueRepresentationReference;
    }

    /**
     * Sets the value of the valueRepresentationReference property.
     *
     * @param value allowed object is
     *              {@link JAXBElement }{@code <}{@link RepresentationReferenceType }{@code >}
     *              {@link JAXBElement }{@code <}{@link RepresentationReferenceType }{@code >}
     *              {@link JAXBElement }{@code <}{@link RepresentationReferenceType }{@code >}
     *              {@link JAXBElement }{@code <}{@link RepresentationReferenceType }{@code >}
     *              {@link JAXBElement }{@code <}{@link RepresentationReferenceType }{@code >}
     */
    public void setValueRepresentationReference(JAXBElement<RepresentationReferenceType> value) {
        this.valueRepresentationReference = value;
    }

    /**
     * Reference to an existing MissingValuesRepresentation using the Reference structure. If this content conflicts with content provided in the ValueRepresentation regarding Missing Values. The content of the MissingValuesRepresentation overrides. TypeOfObject will be MissingValuesRepresentation
     *
     * @return possible object is
     * {@link ReferenceType }
     */
    public ReferenceType getMissingValuesReference() {
        return missingValuesReference;
    }

    /**
     * Sets the value of the missingValuesReference property.
     *
     * @param value allowed object is
     *              {@link ReferenceType }
     */
    public void setMissingValuesReference(ReferenceType value) {
        this.missingValuesReference = value;
    }

    /**
     * Records the measurement unit, for example, 'km', 'miles', etc. Supports the use of a controlled vocabulary.
     *
     * @return possible object is
     * {@link CodeValueType }
     */
    public CodeValueType getMeasurementUnit() {
        return measurementUnit;
    }

    /**
     * Sets the value of the measurementUnit property.
     *
     * @param value allowed object is
     *              {@link CodeValueType }
     */
    public void setMeasurementUnit(CodeValueType value) {
        this.measurementUnit = value;
    }

    /**
     * Identifies the difference between the date applied to the data as a whole and this specific item such as previous year's income or residence 5 years ago.
     *
     * @return possible object is
     * {@link ContentDateOffsetType }
     */
    public ContentDateOffsetType getContentDateOffset() {
        return contentDateOffset;
    }

    /**
     * Sets the value of the contentDateOffset property.
     *
     * @param value allowed object is
     *              {@link ContentDateOffsetType }
     */
    public void setContentDateOffset(ContentDateOffsetType value) {
        this.contentDateOffset = value;
    }

    /**
     * Indicates the type of aggregation method used. Supports the use of a controlled vocabulary.
     *
     * @return possible object is
     * {@link CodeValueType }
     */
    public CodeValueType getAggregationMethod() {
        return aggregationMethod;
    }

    /**
     * Sets the value of the aggregationMethod property.
     *
     * @param value allowed object is
     *              {@link CodeValueType }
     */
    public void setAggregationMethod(CodeValueType value) {
        this.aggregationMethod = value;
    }

    /**
     * Gets the value of the additivity property.
     *
     * @return possible object is
     * {@link AdditivityCodeType }
     */
    public AdditivityCodeType getAdditivity() {
        return additivity;
    }

    /**
     * Sets the value of the additivity property.
     *
     * @param value allowed object is
     *              {@link AdditivityCodeType }
     */
    public void setAdditivity(AdditivityCodeType value) {
        this.additivity = value;
    }

}

//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.11 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2017.01.04 at 03:10:13 PM CST 
//


package Metadata.Specifications.DDI.LifeCycle.reusable;

import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlSchemaType;
import javax.xml.bind.annotation.XmlSeeAlso;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.adapters.CollapsedStringAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;


/**
 * Used to identify described maintainable objects for purposes of internal and/or external referencing. Elements of this type may be maintained as independent objects (outside of a parent object). Provides containers for Uniform Resource Name (URN) as well as ID information. An entity can either be identified either by a URN and/or an identification sequence. At a minimum, one or the other is required. You must designate they type of URN supported by your agency, either "Canonical" or "Deprecated". To fully support interoperability both the DDI URN and the full identification sequence should be used. Note that to support interoperability of the canonical and deprecated URN, at minimum the MaintainableIdentifier and TypeOfMaintainableObject should be supplied if the canonical URN is being used by the agency. If both URN and the identification sequence is used, and there is any conflict, the URN takes precedence. The element can be designated as an addition, replacement, or deletion to facilitate tracking changes. In addtion to the elements and attributes inherited from AbstractIdentifiable, additional information regarding the versioning process can be provided; version date, the person and/or organization within the maintenance agency responsible for the change as either text or reference, and the reason for the change. If the object created was based on an exisiting object (other than by versioning), the object on which it is based can be identified using BasedOnReference. In addition to UserID, versionable and maintainable objects may also designate additional user specific properties expressed as a key/value pair using UserAttributePair. Maintainable objects may also contain any notes related to the objects they contain, identification of the software used to create and/or manage the metadata, a statement of the metadata quality, and a default URI value to use for external external references. The attribute xml:lang can be used to provide specification of the default language of the metadata contents. When the isPublished attribute is set to "true" it indicates to the user that they may safely reference the contents as they will continue to be accessible and any changes in the non-administrative content will be tracked by a versioning mechanism.
 * <p>
 * <p>Java class for AbstractMaintainableType complex type.
 * <p>
 * <p>The following schema fragment specifies the expected content contained within this class.
 * <p>
 * <pre>
 * &lt;complexType name="AbstractMaintainableType"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{ddi:reusable:3_2}AbstractVersionableType"&gt;
 *       &lt;sequence&gt;
 *         &lt;element ref="{ddi:reusable:3_2}Note" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}Software" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}MetadataQuality" maxOccurs="unbounded" minOccurs="0"/&gt;
 *       &lt;/sequence&gt;
 *       &lt;attribute name="externalReferenceDefaultURI" type="{http://www.w3.org/2001/XMLSchema}anyURI" /&gt;
 *       &lt;attribute name="isPublished" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" /&gt;
 *       &lt;attribute ref="{http://www.w3.org/XML/1998/namespace}lang"/&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "AbstractMaintainableType", propOrder = {
        "note",
        "software",
        "metadataQuality"
})
@XmlSeeAlso({
        MaintainableType.class
})
public abstract class AbstractMaintainableType
        extends AbstractVersionableType {

    @XmlElement(name = "Note")
    protected List<NoteType> note;
    @XmlElement(name = "Software")
    protected List<SoftwareType> software;
    @XmlElement(name = "MetadataQuality")
    protected List<MetadataQualityType> metadataQuality;
    @XmlAttribute(name = "externalReferenceDefaultURI")
    @XmlSchemaType(name = "anyURI")
    protected String externalReferenceDefaultURI;
    @XmlAttribute(name = "isPublished")
    protected Boolean isPublished;
    @XmlAttribute(name = "lang", namespace = "http://www.w3.org/XML/1998/namespace")
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlSchemaType(name = "language")
    protected String lang;

    /**
     * Note allows for the attachment of a piece of additional information to any object with an ID. Note facilitates capturing temporary processing notes such as "Review and approval required". A single note can be attached to multiple objects by reference to the objects. Note may also contain content for a needed object that has been reported for addition in a later version of the schema. Ideally this should be handled by a local extension, but Note can accommodate run-time extensions when required. The Note should be housed within the Maintainable object that contains the referenced objects. In this way the user is ensured of receiving all known Note attachments when the maintainable content is delivered. This means that if a Note references objects within multiple Maintainable objects, the Note should be repeated in each Maintainable and reference only those objects with that Maintainable.Gets the value of the note property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the note property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getNote().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link NoteType }
     */
    public List<NoteType> getNote() {
        if (note == null) {
            note = new ArrayList<NoteType>();
        }
        return this.note;
    }

    /**
     * Indicate the software used to create and/or manage the metadata. This is repeatable to allow for multiple softwares or multiple functions. If this information is important it is advisable to provide it in each maintainable so that it does not become separated from the internal content if the metadata is re-factored.Gets the value of the software property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the software property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSoftware().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link SoftwareType }
     */
    public List<SoftwareType> getSoftware() {
        if (software == null) {
            software = new ArrayList<SoftwareType>();
        }
        return this.software;
    }

    /**
     * An assessment of the quality of the metadata within the Maintainable object, e.g. the quality of the transcription, completeness, editing status, etc.Gets the value of the metadataQuality property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the metadataQuality property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getMetadataQuality().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link MetadataQualityType }
     */
    public List<MetadataQualityType> getMetadataQuality() {
        if (metadataQuality == null) {
            metadataQuality = new ArrayList<MetadataQualityType>();
        }
        return this.metadataQuality;
    }

    /**
     * Gets the value of the externalReferenceDefaultURI property.
     *
     * @return possible object is
     * {@link String }
     */
    public String getExternalReferenceDefaultURI() {
        return externalReferenceDefaultURI;
    }

    /**
     * Sets the value of the externalReferenceDefaultURI property.
     *
     * @param value allowed object is
     *              {@link String }
     */
    public void setExternalReferenceDefaultURI(String value) {
        this.externalReferenceDefaultURI = value;
    }

    /**
     * Gets the value of the isPublished property.
     *
     * @return possible object is
     * {@link Boolean }
     */
    public boolean isIsPublished() {
        if (isPublished == null) {
            return false;
        } else {
            return isPublished;
        }
    }

    /**
     * Sets the value of the isPublished property.
     *
     * @param value allowed object is
     *              {@link Boolean }
     */
    public void setIsPublished(Boolean value) {
        this.isPublished = value;
    }

    /**
     * This is used to designate the language of the metadata content of the maintainable. If a lower level xml:lang attribute conflicts with the content at the maintainable level, the object level value takes precedence.
     *
     * @return possible object is
     * {@link String }
     */
    public String getLang() {
        return lang;
    }

    /**
     * Sets the value of the lang property.
     *
     * @param value allowed object is
     *              {@link String }
     */
    public void setLang(String value) {
        this.lang = value;
    }

}

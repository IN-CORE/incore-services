//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.11 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2017.01.04 at 03:10:13 PM CST 
//


package Metadata.Specifications.DDI.LifeCycle.comparative;

import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;

import Metadata.Specifications.DDI.LifeCycle.reusable.LabelType;
import Metadata.Specifications.DDI.LifeCycle.reusable.NameType;
import Metadata.Specifications.DDI.LifeCycle.reusable.ProcessingInstructionReferenceType;
import Metadata.Specifications.DDI.LifeCycle.reusable.StructuredStringType;
import Metadata.Specifications.DDI.LifeCycle.reusable.VersionableType;


/**
 * Maps between any two managed representations. In addition to representation types held in a ManagagedRepresentationScheme, managed representations include CategoryScheme and coded representations which include CodeList, GeographicStructureCode or GeographicLocationCode. Note that the source can be any managed representation including a CodeList, GeographicStructure or GeographicLocation. Note that comparisons between two category schemes is best handled by CategoryMap. In addition to the standard name, label, and description of the RepresentationMap, identifies the source representation and target representation (which should be a CodeList, GeographicStructure, or GeographicLocation), describes the correspondence between the source and target, allows for the use of a GenerationInstruction to describe the recoding process, and indicates if this a general mapping or a mapping for a specific purpose.
 * <p>
 * <p>Java class for RepresentationMapType complex type.
 * <p>
 * <p>The following schema fragment specifies the expected content contained within this class.
 * <p>
 * <pre>
 * &lt;complexType name="RepresentationMapType"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{ddi:reusable:3_2}VersionableType"&gt;
 *       &lt;sequence&gt;
 *         &lt;element ref="{ddi:comparative:3_2}RepresentationMapName" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}Label" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}Description" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:comparative:3_2}SourceRepresentation"/&gt;
 *         &lt;element ref="{ddi:comparative:3_2}TargetRepresentation"/&gt;
 *         &lt;element ref="{ddi:comparative:3_2}Correspondence" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}ProcessingInstructionReference"/&gt;
 *       &lt;/sequence&gt;
 *       &lt;attribute name="contextSpecificComparison" type="{http://www.w3.org/2001/XMLSchema}boolean" /&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "RepresentationMapType", propOrder = {
        "representationMapName",
        "label",
        "description",
        "sourceRepresentation",
        "targetRepresentation",
        "correspondence",
        "processingInstructionReference"
})
public class RepresentationMapType
        extends VersionableType {

    @XmlElement(name = "RepresentationMapName")
    protected List<NameType> representationMapName;
    @XmlElement(name = "Label", namespace = "ddi:reusable:3_2")
    protected List<LabelType> label;
    @XmlElement(name = "Description", namespace = "ddi:reusable:3_2")
    protected StructuredStringType description;
    @XmlElement(name = "SourceRepresentation", required = true)
    protected SourceRepresentationType sourceRepresentation;
    @XmlElement(name = "TargetRepresentation", required = true)
    protected TargetRepresentationType targetRepresentation;
    @XmlElement(name = "Correspondence")
    protected CorrespondenceType correspondence;
    @XmlElement(name = "ProcessingInstructionReference", namespace = "ddi:reusable:3_2", required = true)
    protected ProcessingInstructionReferenceType processingInstructionReference;
    @XmlAttribute(name = "contextSpecificComparison")
    protected Boolean contextSpecificComparison;

    /**
     * A name for the RepresentationMap. May be expressed in multiple languages. Repeat the element to express names with different content, for example different names for different systems.Gets the value of the representationMapName property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the representationMapName property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getRepresentationMapName().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link NameType }
     */
    public List<NameType> getRepresentationMapName() {
        if (representationMapName == null) {
            representationMapName = new ArrayList<NameType>();
        }
        return this.representationMapName;
    }

    /**
     * A display label for the RepresentationMap. May be expressed in multiple languages. Repeat for labels with different content, for example, labels with differing length limitations.Gets the value of the label property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the label property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getLabel().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link LabelType }
     */
    public List<LabelType> getLabel() {
        if (label == null) {
            label = new ArrayList<LabelType>();
        }
        return this.label;
    }

    /**
     * A description of the content and purpose of the RepresentationMap. May be expressed in multiple languages and supports the use of structured content.
     *
     * @return possible object is
     * {@link StructuredStringType }
     */
    public StructuredStringType getDescription() {
        return description;
    }

    /**
     * Sets the value of the description property.
     *
     * @param value allowed object is
     *              {@link StructuredStringType }
     */
    public void setDescription(StructuredStringType value) {
        this.description = value;
    }

    /**
     * Provides a reference to the managed content of a representation which acts as the source object in the Source/Target comparison pair. May be a ManagedRepresentation or a specific CategoryScheme, CodeList, GeographicRepresentation, or GeographicLocation. Allows for the optional reference to a Concept when context is important. For example, a ManagedNumericRepresentation within the context of Age.
     *
     * @return possible object is
     * {@link SourceRepresentationType }
     */
    public SourceRepresentationType getSourceRepresentation() {
        return sourceRepresentation;
    }

    /**
     * Sets the value of the sourceRepresentation property.
     *
     * @param value allowed object is
     *              {@link SourceRepresentationType }
     */
    public void setSourceRepresentation(SourceRepresentationType value) {
        this.sourceRepresentation = value;
    }

    /**
     * Provides a reference to the managed content of a representation which acts as the target object in the Source/Target comparison pair. May be a ManagedRepresentation or a specific CategoryScheme, CodeList, GeographicRepresentation, or GeographicLocation. Supports the ability to limit code coverage as appropriate for the coding structure referenced.
     *
     * @return possible object is
     * {@link TargetRepresentationType }
     */
    public TargetRepresentationType getTargetRepresentation() {
        return targetRepresentation;
    }

    /**
     * Sets the value of the targetRepresentation property.
     *
     * @param value allowed object is
     *              {@link TargetRepresentationType }
     */
    public void setTargetRepresentation(TargetRepresentationType value) {
        this.targetRepresentation = value;
    }

    /**
     * Describe the level of similarity and difference between the Source and the Target contents.
     *
     * @return possible object is
     * {@link CorrespondenceType }
     */
    public CorrespondenceType getCorrespondence() {
        return correspondence;
    }

    /**
     * Sets the value of the correspondence property.
     *
     * @param value allowed object is
     *              {@link CorrespondenceType }
     */
    public void setCorrespondence(CorrespondenceType value) {
        this.correspondence = value;
    }

    /**
     * Allows for use of programmatic logic to construct a detailed comparison map between individual codes in the source and target structures by reference. TypeOfObject should be set to GenerationInstruction or GeneralInstruction. This reference allows for specifying ParameterLinkages at point of use.
     *
     * @return possible object is
     * {@link ProcessingInstructionReferenceType }
     */
    public ProcessingInstructionReferenceType getProcessingInstructionReference() {
        return processingInstructionReference;
    }

    /**
     * Sets the value of the processingInstructionReference property.
     *
     * @param value allowed object is
     *              {@link ProcessingInstructionReferenceType }
     */
    public void setProcessingInstructionReference(ProcessingInstructionReferenceType value) {
        this.processingInstructionReference = value;
    }

    /**
     * Gets the value of the contextSpecificComparison property.
     *
     * @return possible object is
     * {@link Boolean }
     */
    public Boolean isContextSpecificComparison() {
        return contextSpecificComparison;
    }

    /**
     * Sets the value of the contextSpecificComparison property.
     *
     * @param value allowed object is
     *              {@link Boolean }
     */
    public void setContextSpecificComparison(Boolean value) {
        this.contextSpecificComparison = value;
    }

}

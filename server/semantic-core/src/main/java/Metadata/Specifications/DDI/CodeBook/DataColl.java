//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.11 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2017.01.05 at 03:37:15 PM CST 
//


package Metadata.Specifications.DDI.CodeBook;

import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlType;


/**
 * <p>Java class for dataCollType complex type.
 * <p>
 * <p>The following schema fragment specifies the expected content contained within this class.
 * <p>
 * <pre>
 * &lt;complexType name="dataCollType"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{ddi:codebook:2_5}baseElementType"&gt;
 *       &lt;sequence&gt;
 *         &lt;element ref="{ddi:codebook:2_5}timeMeth" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:codebook:2_5}dataCollector" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:codebook:2_5}collectorTraining" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:codebook:2_5}frequenc" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:codebook:2_5}sampProc" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:codebook:2_5}sampleFrame" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:codebook:2_5}targetSampleSize" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:codebook:2_5}deviat" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:codebook:2_5}collMode" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:codebook:2_5}resInstru" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:codebook:2_5}instrumentDevelopment" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:codebook:2_5}sources" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:codebook:2_5}collSitu" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:codebook:2_5}actMin" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:codebook:2_5}ConOps" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:codebook:2_5}weight" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:codebook:2_5}cleanOps" maxOccurs="unbounded" minOccurs="0"/&gt;
 *       &lt;/sequence&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "dataCollType", propOrder = {
        "timeMeths",
        "dataCollectors",
        "collectorTrainings",
        "frequencs",
        "sampProcs",
        "sampleFrames",
        "targetSampleSizes",
        "deviats",
        "collModes",
        "resInstrus",
        "instrumentDevelopments",
        "sources",
        "collSitus",
        "actMins",
        "conOps",
        "weights",
        "cleanOps"
})
@XmlRootElement(name = "dataColl")
public class DataColl
        extends BaseElementType {

    @XmlElement(name = "timeMeth")
    protected List<TimeMeth> timeMeths;
    @XmlElement(name = "dataCollector")
    protected List<DataCollector> dataCollectors;
    @XmlElement(name = "collectorTraining")
    protected List<CollectorTraining> collectorTrainings;
    @XmlElement(name = "frequenc")
    protected List<Frequenc> frequencs;
    @XmlElement(name = "sampProc")
    protected List<ConceptualTextType> sampProcs;
    @XmlElement(name = "sampleFrame")
    protected List<SampleFrame> sampleFrames;
    @XmlElement(name = "targetSampleSize")
    protected List<TargetSampleSize> targetSampleSizes;
    @XmlElement(name = "deviat")
    protected List<SimpleTextType> deviats;
    @XmlElement(name = "collMode")
    protected List<ConceptualTextType> collModes;
    @XmlElement(name = "resInstru")
    protected List<ResInstru> resInstrus;
    @XmlElement(name = "instrumentDevelopment")
    protected List<InstrumentDevelopment> instrumentDevelopments;
    protected Sources sources;
    @XmlElement(name = "collSitu")
    protected List<SimpleTextType> collSitus;
    @XmlElement(name = "actMin")
    protected List<SimpleTextType> actMins;
    @XmlElement(name = "ConOps")
    protected List<ConOps> conOps;
    @XmlElement(name = "weight")
    protected List<SimpleTextType> weights;
    protected List<CleanOps> cleanOps;

    /**
     * Gets the value of the timeMeths property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the timeMeths property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getTimeMeths().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link TimeMeth }
     */
    public List<TimeMeth> getTimeMeths() {
        if (timeMeths == null) {
            timeMeths = new ArrayList<TimeMeth>();
        }
        return this.timeMeths;
    }

    /**
     * Gets the value of the dataCollectors property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the dataCollectors property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDataCollectors().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link DataCollector }
     */
    public List<DataCollector> getDataCollectors() {
        if (dataCollectors == null) {
            dataCollectors = new ArrayList<DataCollector>();
        }
        return this.dataCollectors;
    }

    /**
     * Gets the value of the collectorTrainings property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the collectorTrainings property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCollectorTrainings().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CollectorTraining }
     */
    public List<CollectorTraining> getCollectorTrainings() {
        if (collectorTrainings == null) {
            collectorTrainings = new ArrayList<CollectorTraining>();
        }
        return this.collectorTrainings;
    }

    /**
     * Gets the value of the frequencs property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the frequencs property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getFrequencs().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Frequenc }
     */
    public List<Frequenc> getFrequencs() {
        if (frequencs == null) {
            frequencs = new ArrayList<Frequenc>();
        }
        return this.frequencs;
    }

    /**
     * Gets the value of the sampProcs property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the sampProcs property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSampProcs().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ConceptualTextType }
     */
    public List<ConceptualTextType> getSampProcs() {
        if (sampProcs == null) {
            sampProcs = new ArrayList<ConceptualTextType>();
        }
        return this.sampProcs;
    }

    /**
     * Gets the value of the sampleFrames property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the sampleFrames property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSampleFrames().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link SampleFrame }
     */
    public List<SampleFrame> getSampleFrames() {
        if (sampleFrames == null) {
            sampleFrames = new ArrayList<SampleFrame>();
        }
        return this.sampleFrames;
    }

    /**
     * Gets the value of the targetSampleSizes property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the targetSampleSizes property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getTargetSampleSizes().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link TargetSampleSize }
     */
    public List<TargetSampleSize> getTargetSampleSizes() {
        if (targetSampleSizes == null) {
            targetSampleSizes = new ArrayList<TargetSampleSize>();
        }
        return this.targetSampleSizes;
    }

    /**
     * Gets the value of the deviats property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the deviats property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDeviats().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link SimpleTextType }
     */
    public List<SimpleTextType> getDeviats() {
        if (deviats == null) {
            deviats = new ArrayList<SimpleTextType>();
        }
        return this.deviats;
    }

    /**
     * Gets the value of the collModes property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the collModes property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCollModes().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ConceptualTextType }
     */
    public List<ConceptualTextType> getCollModes() {
        if (collModes == null) {
            collModes = new ArrayList<ConceptualTextType>();
        }
        return this.collModes;
    }

    /**
     * Gets the value of the resInstrus property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the resInstrus property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getResInstrus().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ResInstru }
     */
    public List<ResInstru> getResInstrus() {
        if (resInstrus == null) {
            resInstrus = new ArrayList<ResInstru>();
        }
        return this.resInstrus;
    }

    /**
     * Gets the value of the instrumentDevelopments property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the instrumentDevelopments property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getInstrumentDevelopments().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link InstrumentDevelopment }
     */
    public List<InstrumentDevelopment> getInstrumentDevelopments() {
        if (instrumentDevelopments == null) {
            instrumentDevelopments = new ArrayList<InstrumentDevelopment>();
        }
        return this.instrumentDevelopments;
    }

    /**
     * Gets the value of the sources property.
     *
     * @return possible object is
     * {@link Sources }
     */
    public Sources getSources() {
        return sources;
    }

    /**
     * Sets the value of the sources property.
     *
     * @param value allowed object is
     *              {@link Sources }
     */
    public void setSources(Sources value) {
        this.sources = value;
    }

    /**
     * Gets the value of the collSitus property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the collSitus property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCollSitus().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link SimpleTextType }
     */
    public List<SimpleTextType> getCollSitus() {
        if (collSitus == null) {
            collSitus = new ArrayList<SimpleTextType>();
        }
        return this.collSitus;
    }

    /**
     * Gets the value of the actMins property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the actMins property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getActMins().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link SimpleTextType }
     */
    public List<SimpleTextType> getActMins() {
        if (actMins == null) {
            actMins = new ArrayList<SimpleTextType>();
        }
        return this.actMins;
    }

    /**
     * Gets the value of the conOps property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the conOps property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getConOps().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ConOps }
     */
    public List<ConOps> getConOps() {
        if (conOps == null) {
            conOps = new ArrayList<ConOps>();
        }
        return this.conOps;
    }

    /**
     * Gets the value of the weights property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the weights property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getWeights().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link SimpleTextType }
     */
    public List<SimpleTextType> getWeights() {
        if (weights == null) {
            weights = new ArrayList<SimpleTextType>();
        }
        return this.weights;
    }

    /**
     * Gets the value of the cleanOps property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the cleanOps property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCleanOps().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CleanOps }
     */
    public List<CleanOps> getCleanOps() {
        if (cleanOps == null) {
            cleanOps = new ArrayList<CleanOps>();
        }
        return this.cleanOps;
    }

}

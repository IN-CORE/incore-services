//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.11 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2017.01.04 at 03:10:13 PM CST 
//


package Metadata.Specifications.DDI.LifeCycle.physicaldataproduct;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlList;
import javax.xml.bind.annotation.XmlSchemaType;
import javax.xml.bind.annotation.XmlSeeAlso;
import javax.xml.bind.annotation.XmlType;

import Metadata.Specifications.DDI.LifeCycle.physicaldataproduct.ncube.tabular.PhysicalTableLocationType;
import Metadata.Specifications.DDI.LifeCycle.reusable.CodeValueType;
import Metadata.Specifications.DDI.LifeCycle.reusable.DelimiterType;


/**
 * Description of the physical location of the value of the object in the data file. Includes information about the data item location and its data type/format if other than the default.
 * <p>
 * <p>Java class for PhysicalLocationType complex type.
 * <p>
 * <p>The following schema fragment specifies the expected content contained within this class.
 * <p>
 * <pre>
 * &lt;complexType name="PhysicalLocationType"&gt;
 *   &lt;complexContent&gt;
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *       &lt;sequence&gt;
 *         &lt;element name="StorageFormat" type="{ddi:reusable:3_2}CodeValueType" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:physicaldataproduct:3_2}Delimiter" minOccurs="0"/&gt;
 *         &lt;sequence&gt;
 *           &lt;element name="StartPosition" type="{http://www.w3.org/2001/XMLSchema}integer" minOccurs="0"/&gt;
 *           &lt;element name="ArrayPosition" type="{http://www.w3.org/2001/XMLSchema}integer" minOccurs="0"/&gt;
 *           &lt;element name="EndPosition" type="{http://www.w3.org/2001/XMLSchema}integer" minOccurs="0"/&gt;
 *           &lt;element name="Width" type="{http://www.w3.org/2001/XMLSchema}integer" minOccurs="0"/&gt;
 *         &lt;/sequence&gt;
 *         &lt;element name="DecimalPositions" type="{http://www.w3.org/2001/XMLSchema}integer" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:physicaldataproduct:3_2}DecimalSeparator" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:physicaldataproduct:3_2}DigitGroupSeparator" minOccurs="0"/&gt;
 *         &lt;element name="LanguageOfData" type="{ddi:reusable:3_2}LanguageList" minOccurs="0"/&gt;
 *         &lt;element name="LocaleOfData" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/&gt;
 *       &lt;/sequence&gt;
 *     &lt;/restriction&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "PhysicalLocationType", propOrder = {
        "storageFormat",
        "delimiter",
        "startPosition",
        "arrayPosition",
        "endPosition",
        "width",
        "decimalPositions",
        "decimalSeparator",
        "digitGroupSeparator",
        "languageOfData",
        "localeOfData"
})
@XmlSeeAlso({
        PhysicalTableLocationType.class
})
public class PhysicalLocationType {

    @XmlElement(name = "StorageFormat")
    protected CodeValueType storageFormat;
    @XmlElement(name = "Delimiter")
    protected DelimiterType delimiter;
    @XmlElement(name = "StartPosition")
    protected BigInteger startPosition;
    @XmlElement(name = "ArrayPosition")
    protected BigInteger arrayPosition;
    @XmlElement(name = "EndPosition")
    protected BigInteger endPosition;
    @XmlElement(name = "Width")
    protected BigInteger width;
    @XmlElement(name = "DecimalPositions")
    protected BigInteger decimalPositions;
    @XmlElement(name = "DecimalSeparator")
    protected String decimalSeparator;
    @XmlElement(name = "DigitGroupSeparator")
    protected String digitGroupSeparator;
    @XmlList
    @XmlElement(name = "LanguageOfData")
    @XmlSchemaType(name = "anySimpleType")
    protected List<String> languageOfData;
    @XmlElement(name = "LocaleOfData")
    protected String localeOfData;

    /**
     * Gets the value of the storageFormat property.
     *
     * @return possible object is
     * {@link CodeValueType }
     */
    public CodeValueType getStorageFormat() {
        return storageFormat;
    }

    /**
     * Sets the value of the storageFormat property.
     *
     * @param value allowed object is
     *              {@link CodeValueType }
     */
    public void setStorageFormat(CodeValueType value) {
        this.storageFormat = value;
    }

    /**
     * Defines the delimiter used to separate variables in a delimited record. The attribute treatConsecutiveDelimiterAsOne indicates how consecutive delimiters should be handed by the software.
     *
     * @return possible object is
     * {@link DelimiterType }
     */
    public DelimiterType getDelimiter() {
        return delimiter;
    }

    /**
     * Sets the value of the delimiter property.
     *
     * @param value allowed object is
     *              {@link DelimiterType }
     */
    public void setDelimiter(DelimiterType value) {
        this.delimiter = value;
    }

    /**
     * Gets the value of the startPosition property.
     *
     * @return possible object is
     * {@link BigInteger }
     */
    public BigInteger getStartPosition() {
        return startPosition;
    }

    /**
     * Sets the value of the startPosition property.
     *
     * @param value allowed object is
     *              {@link BigInteger }
     */
    public void setStartPosition(BigInteger value) {
        this.startPosition = value;
    }

    /**
     * Gets the value of the arrayPosition property.
     *
     * @return possible object is
     * {@link BigInteger }
     */
    public BigInteger getArrayPosition() {
        return arrayPosition;
    }

    /**
     * Sets the value of the arrayPosition property.
     *
     * @param value allowed object is
     *              {@link BigInteger }
     */
    public void setArrayPosition(BigInteger value) {
        this.arrayPosition = value;
    }

    /**
     * Gets the value of the endPosition property.
     *
     * @return possible object is
     * {@link BigInteger }
     */
    public BigInteger getEndPosition() {
        return endPosition;
    }

    /**
     * Sets the value of the endPosition property.
     *
     * @param value allowed object is
     *              {@link BigInteger }
     */
    public void setEndPosition(BigInteger value) {
        this.endPosition = value;
    }

    /**
     * Gets the value of the width property.
     *
     * @return possible object is
     * {@link BigInteger }
     */
    public BigInteger getWidth() {
        return width;
    }

    /**
     * Sets the value of the width property.
     *
     * @param value allowed object is
     *              {@link BigInteger }
     */
    public void setWidth(BigInteger value) {
        this.width = value;
    }

    /**
     * Gets the value of the decimalPositions property.
     *
     * @return possible object is
     * {@link BigInteger }
     */
    public BigInteger getDecimalPositions() {
        return decimalPositions;
    }

    /**
     * Sets the value of the decimalPositions property.
     *
     * @param value allowed object is
     *              {@link BigInteger }
     */
    public void setDecimalPositions(BigInteger value) {
        this.decimalPositions = value;
    }

    /**
     * The character used to separate the integer and the fraction part of a number (if an explicit separator is used in the data). Allowed values are: None (default), Dot, Comma, Other. On the basis of the data definition in DDI documents, data processing tools could compute the necessary precision width on the basis of the format width and the existence of separators. Appropriate data types could be used, i.e. float or double, short or long. The decimal separator definition only makes sense with some XML Schema primitives.
     *
     * @return possible object is
     * {@link String }
     */
    public String getDecimalSeparator() {
        return decimalSeparator;
    }

    /**
     * Sets the value of the decimalSeparator property.
     *
     * @param value allowed object is
     *              {@link String }
     */
    public void setDecimalSeparator(String value) {
        this.decimalSeparator = value;
    }

    /**
     * The character used to separate groups of digits (if an explicit separator is used in the data). Allowed values are: None (default), Dot, Comma, Other. The decimal separator definition makes only sense with some XML Schema primitives.
     *
     * @return possible object is
     * {@link String }
     */
    public String getDigitGroupSeparator() {
        return digitGroupSeparator;
    }

    /**
     * Sets the value of the digitGroupSeparator property.
     *
     * @param value allowed object is
     *              {@link String }
     */
    public void setDigitGroupSeparator(String value) {
        this.digitGroupSeparator = value;
    }

    /**
     * Gets the value of the languageOfData property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the languageOfData property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getLanguageOfData().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     */
    public List<String> getLanguageOfData() {
        if (languageOfData == null) {
            languageOfData = new ArrayList<String>();
        }
        return this.languageOfData;
    }

    /**
     * Gets the value of the localeOfData property.
     *
     * @return possible object is
     * {@link String }
     */
    public String getLocaleOfData() {
        return localeOfData;
    }

    /**
     * Sets the value of the localeOfData property.
     *
     * @param value allowed object is
     *              {@link String }
     */
    public void setLocaleOfData(String value) {
        this.localeOfData = value;
    }

}

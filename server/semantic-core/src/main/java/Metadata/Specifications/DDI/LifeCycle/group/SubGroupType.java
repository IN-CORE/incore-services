//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.11 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2017.01.04 at 03:10:13 PM CST 
//


package Metadata.Specifications.DDI.LifeCycle.group;

import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlElementRefs;
import javax.xml.bind.annotation.XmlElements;
import javax.xml.bind.annotation.XmlType;

import Metadata.Specifications.DDI.LifeCycle.archive.ArchiveType;
import Metadata.Specifications.DDI.LifeCycle.comparative.ComparisonType;
import Metadata.Specifications.DDI.LifeCycle.conceptualcomponent.ConceptualComponentType;
import Metadata.Specifications.DDI.LifeCycle.datacollection.DataCollectionType;
import Metadata.Specifications.DDI.LifeCycle.ddiprofile.DDIProfileType;
import Metadata.Specifications.DDI.LifeCycle.logicalproduct.BaseLogicalProductType;
import Metadata.Specifications.DDI.LifeCycle.logicalproduct.LogicalProductType;
import Metadata.Specifications.DDI.LifeCycle.physicaldataproduct.PhysicalDataProductType;
import Metadata.Specifications.DDI.LifeCycle.physicalinstance.PhysicalInstanceType;
import Metadata.Specifications.DDI.LifeCycle.reusable.AuthorizationSourceType;
import Metadata.Specifications.DDI.LifeCycle.reusable.CitationType;
import Metadata.Specifications.DDI.LifeCycle.reusable.CodeValueType;
import Metadata.Specifications.DDI.LifeCycle.reusable.CoverageType;
import Metadata.Specifications.DDI.LifeCycle.reusable.EmbargoType;
import Metadata.Specifications.DDI.LifeCycle.reusable.FundingInformationType;
import Metadata.Specifications.DDI.LifeCycle.reusable.InternationalStringType;
import Metadata.Specifications.DDI.LifeCycle.reusable.KindOfDataType;
import Metadata.Specifications.DDI.LifeCycle.reusable.OtherMaterialType;
import Metadata.Specifications.DDI.LifeCycle.reusable.ReferenceType;
import Metadata.Specifications.DDI.LifeCycle.reusable.SchemeReferenceType;
import Metadata.Specifications.DDI.LifeCycle.reusable.SeriesStatementType;
import Metadata.Specifications.DDI.LifeCycle.reusable.StructuredStringType;
import Metadata.Specifications.DDI.LifeCycle.reusable.VersionableType;
import Metadata.Specifications.DDI.LifeCycle.studyunit.StudyUnitType;


/**
 * The subgroup element is a container for a group that is a child of a higher-level group described in this module, but may also be a parent to other (subordinate) groups. A studyunit can be fully described, or just referenced, within its subgroup container. The purpose of sub-groups is described using the attributes which summarize relationships along the dimensions of time, panel, geography, instrument and language. These attributes allow the purpose to be machine-actionable, while the sub-group also includes an element for describing the purpose in human-readable format. A SubGroup contains a Citation, Abstract, information on authorization, the universe of the sub-group, series statement, quality statements, funding information, purpose, coverage, analysis units covered, kind of data, other materials, and embargo information. It then allows all maintainable structures within the StudyUnit to be expressed at the SubGroup level.
 * <p>
 * <p>Java class for SubGroupType complex type.
 * <p>
 * <p>The following schema fragment specifies the expected content contained within this class.
 * <p>
 * <pre>
 * &lt;complexType name="SubGroupType"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{ddi:reusable:3_2}VersionableType"&gt;
 *       &lt;sequence&gt;
 *         &lt;element ref="{ddi:reusable:3_2}Citation" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}Abstract" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}AuthorizationSource" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}UniverseReference" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}SeriesStatement" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}QualityStatementReference" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}QualityStatementSchemeReference" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}FundingInformation" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}Purpose" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}Coverage" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}AnalysisUnit" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}AnalysisUnitsCovered" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}KindOfData" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}OtherMaterial" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element ref="{ddi:reusable:3_2}Embargo" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:conceptualcomponent:3_2}ConceptualComponent"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}ConceptualComponentReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:datacollection:3_2}DataCollection"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}DataCollectionReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:logicalproduct:3_2}BaseLogicalProduct"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}LogicalProductReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:physicaldataproduct:3_2}PhysicalDataProduct"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}PhysicalDataProductReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:physicalinstance:3_2}PhysicalInstance"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}PhysicalInstanceReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:archive:3_2}Archive"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}ArchiveReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:ddiprofile:3_2}DDIProfile"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}DDIProfileReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:comparative:3_2}Comparison"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}ComparisonReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:studyunit:3_2}StudyUnit"/&gt;
 *           &lt;element ref="{ddi:reusable:3_2}StudyUnitReference"/&gt;
 *         &lt;/choice&gt;
 *         &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;element ref="{ddi:group:3_2}SubGroup"/&gt;
 *           &lt;element ref="{ddi:group:3_2}SubGroupReference"/&gt;
 *         &lt;/choice&gt;
 *       &lt;/sequence&gt;
 *       &lt;attribute name="time" type="{ddi:group:3_2}TimeGroupCodeType" default="T0" /&gt;
 *       &lt;attribute name="captureInstrument" type="{ddi:group:3_2}InstrumentGroupCodeType" default="I0" /&gt;
 *       &lt;attribute name="panel" type="{ddi:group:3_2}PanelGroupCodeType" default="P0" /&gt;
 *       &lt;attribute name="geography" type="{ddi:group:3_2}GeographyGroupCodeType" default="G0" /&gt;
 *       &lt;attribute name="dataProduct" type="{ddi:group:3_2}DataProductGroupCodeType" default="D0" /&gt;
 *       &lt;attribute name="languageRelationship" type="{ddi:group:3_2}LanguageGroupCodeType" default="L0" /&gt;
 *       &lt;attribute name="userDefinedGroupProperty" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
 *       &lt;attribute name="userDefinedGroupPropertyValue" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
 *       &lt;attribute name="isInheritable" type="{http://www.w3.org/2001/XMLSchema}boolean" default="true" /&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "SubGroupType", propOrder = {
        "citation",
        "_abstract",
        "authorizationSource",
        "universeReference",
        "seriesStatement",
        "qualityStatementReference",
        "qualityStatementSchemeReference",
        "fundingInformation",
        "purpose",
        "coverage",
        "analysisUnit",
        "analysisUnitsCovered",
        "kindOfData",
        "otherMaterial",
        "embargo",
        "conceptualComponentOrConceptualComponentReference",
        "dataCollectionOrDataCollectionReference",
        "baseLogicalProductOrLogicalProductReference",
        "physicalDataProductOrPhysicalDataProductReference",
        "physicalInstanceOrPhysicalInstanceReference",
        "archiveOrArchiveReference",
        "ddiProfileOrDDIProfileReference",
        "comparisonOrComparisonReference",
        "studyUnitOrStudyUnitReference",
        "subGroupOrSubGroupReference"
})
public class SubGroupType
        extends VersionableType {

    @XmlElement(name = "Citation", namespace = "ddi:reusable:3_2")
    protected CitationType citation;
    @XmlElement(name = "Abstract", namespace = "ddi:reusable:3_2")
    protected StructuredStringType _abstract;
    @XmlElement(name = "AuthorizationSource", namespace = "ddi:reusable:3_2")
    protected List<AuthorizationSourceType> authorizationSource;
    @XmlElement(name = "UniverseReference", namespace = "ddi:reusable:3_2")
    protected ReferenceType universeReference;
    @XmlElement(name = "SeriesStatement", namespace = "ddi:reusable:3_2")
    protected List<SeriesStatementType> seriesStatement;
    @XmlElement(name = "QualityStatementReference", namespace = "ddi:reusable:3_2")
    protected List<ReferenceType> qualityStatementReference;
    @XmlElement(name = "QualityStatementSchemeReference", namespace = "ddi:reusable:3_2")
    protected List<SchemeReferenceType> qualityStatementSchemeReference;
    @XmlElement(name = "FundingInformation", namespace = "ddi:reusable:3_2")
    protected List<FundingInformationType> fundingInformation;
    @XmlElement(name = "Purpose", namespace = "ddi:reusable:3_2")
    protected StructuredStringType purpose;
    @XmlElement(name = "Coverage", namespace = "ddi:reusable:3_2")
    protected CoverageType coverage;
    @XmlElement(name = "AnalysisUnit", namespace = "ddi:reusable:3_2")
    protected List<CodeValueType> analysisUnit;
    @XmlElement(name = "AnalysisUnitsCovered", namespace = "ddi:reusable:3_2")
    protected InternationalStringType analysisUnitsCovered;
    @XmlElement(name = "KindOfData", namespace = "ddi:reusable:3_2")
    protected List<KindOfDataType> kindOfData;
    @XmlElement(name = "OtherMaterial", namespace = "ddi:reusable:3_2")
    protected List<OtherMaterialType> otherMaterial;
    @XmlElement(name = "Embargo", namespace = "ddi:reusable:3_2")
    protected List<EmbargoType> embargo;
    @XmlElements({
            @XmlElement(name = "ConceptualComponent", namespace = "ddi:conceptualcomponent:3_2", type = ConceptualComponentType.class),
            @XmlElement(name = "ConceptualComponentReference", namespace = "ddi:reusable:3_2", type = ReferenceType.class)
    })
    protected List<Object> conceptualComponentOrConceptualComponentReference;
    @XmlElements({
            @XmlElement(name = "DataCollection", namespace = "ddi:datacollection:3_2", type = DataCollectionType.class),
            @XmlElement(name = "DataCollectionReference", namespace = "ddi:reusable:3_2", type = ReferenceType.class)
    })
    protected List<Object> dataCollectionOrDataCollectionReference;
    @XmlElementRefs({
            @XmlElementRef(name = "LogicalProductReference", namespace = "ddi:reusable:3_2", type = JAXBElement.class, required = false),
            @XmlElementRef(name = "BaseLogicalProduct", namespace = "ddi:logicalproduct:3_2", type = JAXBElement.class, required = false)
    })
    protected List<JAXBElement<?>> baseLogicalProductOrLogicalProductReference;
    @XmlElements({
            @XmlElement(name = "PhysicalDataProduct", namespace = "ddi:physicaldataproduct:3_2", type = PhysicalDataProductType.class),
            @XmlElement(name = "PhysicalDataProductReference", namespace = "ddi:reusable:3_2", type = ReferenceType.class)
    })
    protected List<Object> physicalDataProductOrPhysicalDataProductReference;
    @XmlElements({
            @XmlElement(name = "PhysicalInstance", namespace = "ddi:physicalinstance:3_2", type = PhysicalInstanceType.class),
            @XmlElement(name = "PhysicalInstanceReference", namespace = "ddi:reusable:3_2", type = ReferenceType.class)
    })
    protected List<Object> physicalInstanceOrPhysicalInstanceReference;
    @XmlElements({
            @XmlElement(name = "Archive", namespace = "ddi:archive:3_2", type = ArchiveType.class),
            @XmlElement(name = "ArchiveReference", namespace = "ddi:reusable:3_2", type = ReferenceType.class)
    })
    protected List<Object> archiveOrArchiveReference;
    @XmlElements({
            @XmlElement(name = "DDIProfile", namespace = "ddi:ddiprofile:3_2", type = DDIProfileType.class),
            @XmlElement(name = "DDIProfileReference", namespace = "ddi:reusable:3_2", type = ReferenceType.class)
    })
    protected List<Object> ddiProfileOrDDIProfileReference;
    @XmlElements({
            @XmlElement(name = "Comparison", namespace = "ddi:comparative:3_2", type = ComparisonType.class),
            @XmlElement(name = "ComparisonReference", namespace = "ddi:reusable:3_2", type = ReferenceType.class)
    })
    protected List<Object> comparisonOrComparisonReference;
    @XmlElements({
            @XmlElement(name = "StudyUnit", namespace = "ddi:studyunit:3_2", type = StudyUnitType.class),
            @XmlElement(name = "StudyUnitReference", namespace = "ddi:reusable:3_2", type = ReferenceType.class)
    })
    protected List<Object> studyUnitOrStudyUnitReference;
    @XmlElements({
            @XmlElement(name = "SubGroup", type = SubGroupType.class),
            @XmlElement(name = "SubGroupReference", type = ReferenceType.class)
    })
    protected List<Object> subGroupOrSubGroupReference;
    @XmlAttribute(name = "time")
    protected TimeGroupCodeType time;
    @XmlAttribute(name = "captureInstrument")
    protected InstrumentGroupCodeType captureInstrument;
    @XmlAttribute(name = "panel")
    protected PanelGroupCodeType panel;
    @XmlAttribute(name = "geography")
    protected GeographyGroupCodeType geography;
    @XmlAttribute(name = "dataProduct")
    protected DataProductGroupCodeType dataProduct;
    @XmlAttribute(name = "languageRelationship")
    protected LanguageGroupCodeType languageRelationship;
    @XmlAttribute(name = "userDefinedGroupProperty")
    protected String userDefinedGroupProperty;
    @XmlAttribute(name = "userDefinedGroupPropertyValue")
    protected String userDefinedGroupPropertyValue;
    @XmlAttribute(name = "isInheritable")
    protected Boolean isInheritable;

    /**
     * The citation for the sub-group. DDI strongly recommends that at minimum a Title be provided.
     *
     * @return possible object is
     * {@link CitationType }
     */
    public CitationType getCitation() {
        return citation;
    }

    /**
     * Sets the value of the citation property.
     *
     * @param value allowed object is
     *              {@link CitationType }
     */
    public void setCitation(CitationType value) {
        this.citation = value;
    }

    /**
     * An abstract of the sub-group unit describing the nature and scope of the data collection, special characteristics of its content. Note that detailed information on the purpose of the sub-group and structured coverage information are to be entered in Purpose and Coverage. Abstract supports multiple language versions of the same content as well as optional formatting of the content.
     *
     * @return possible object is
     * {@link StructuredStringType }
     */
    public StructuredStringType getAbstract() {
        return _abstract;
    }

    /**
     * Sets the value of the abstract property.
     *
     * @param value allowed object is
     *              {@link StructuredStringType }
     */
    public void setAbstract(StructuredStringType value) {
        this._abstract = value;
    }

    /**
     * Identifies the authorizing agency for the sub-group and allows for the full text of the authorization (law, regulation, or other form of authorization). May be used to list authorizations from oversight committees and other regulatory agencies.Gets the value of the authorizationSource property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the authorizationSource property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getAuthorizationSource().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link AuthorizationSourceType }
     */
    public List<AuthorizationSourceType> getAuthorizationSource() {
        if (authorizationSource == null) {
            authorizationSource = new ArrayList<AuthorizationSourceType>();
        }
        return this.authorizationSource;
    }

    /**
     * Reference to the universe statement from the universe scheme, describing the sub-group of persons or other elements that are the object of research and to which any analytic results refer. Age, nationality, and residence commonly help to delineate a given universe, but any of a number of factors may be involved, such as sex, race, income, veteran status, criminal convictions, etc. The universe may consist of elements other than persons, such as housing units, court cases, deaths, countries, etc. In general, it should be possible to tell from the description of the universe whether a given individual or element (hypothetical or real) is a member of the population under sub-group. A universe may be described as "inclusive" or "exclusive". This sub-group level reference is normally to the top level of the UniverseScheme.
     *
     * @return possible object is
     * {@link ReferenceType }
     */
    public ReferenceType getUniverseReference() {
        return universeReference;
    }

    /**
     * Sets the value of the universeReference property.
     *
     * @param value allowed object is
     *              {@link ReferenceType }
     */
    public void setUniverseReference(ReferenceType value) {
        this.universeReference = value;
    }

    /**
     * A sub-group, particularly one in a series, may be the result of two series merging into a single sub-group. The new sub-group belongs to both series. For example, Niger now fields the UNICEF Multiple Indicators Cluster Survey (MICS) and the Demographic and Health Survey as a single merged instrument.Gets the value of the seriesStatement property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the seriesStatement property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSeriesStatement().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link SeriesStatementType }
     */
    public List<SeriesStatementType> getSeriesStatement() {
        if (seriesStatement == null) {
            seriesStatement = new ArrayList<SeriesStatementType>();
        }
        return this.seriesStatement;
    }

    /**
     * A reference to a Quality Statement pertaining to the quality of the subgroup overall, metadata, or data to which it is associated. Quality statements may be related to external quality standards.Gets the value of the qualityStatementReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the qualityStatementReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getQualityStatementReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ReferenceType }
     */
    public List<ReferenceType> getQualityStatementReference() {
        if (qualityStatementReference == null) {
            qualityStatementReference = new ArrayList<ReferenceType>();
        }
        return this.qualityStatementReference;
    }

    /**
     * A reference to a QualityStatementScheme containing statements of quality related to the quality of the sub-group methodology, metadata, or data. Quality statements may be related to external quality standards.Gets the value of the qualityStatementSchemeReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the qualityStatementSchemeReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getQualityStatementSchemeReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link SchemeReferenceType }
     */
    public List<SchemeReferenceType> getQualityStatementSchemeReference() {
        if (qualityStatementSchemeReference == null) {
            qualityStatementSchemeReference = new ArrayList<SchemeReferenceType>();
        }
        return this.qualityStatementSchemeReference;
    }

    /**
     * Contains details of the sub-group unit's funding, including information about grants, agencies, etc.Gets the value of the fundingInformation property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the fundingInformation property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getFundingInformation().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link FundingInformationType }
     */
    public List<FundingInformationType> getFundingInformation() {
        if (fundingInformation == null) {
            fundingInformation = new ArrayList<FundingInformationType>();
        }
        return this.fundingInformation;
    }

    /**
     * The purpose of the sub-group, why the sub-group took place. This should include detailed information on the investigator's primary sub-group questions or hypotheses as well as information on any legal basis for the data collection, such as laws requiring the collection of census data for apportionment purposes. Legal or other authorization should be provided in detail within AuthorizationSource. Purpose supports multiple language versions of the same content as well as optional formatting of the content.
     *
     * @return possible object is
     * {@link StructuredStringType }
     */
    public StructuredStringType getPurpose() {
        return purpose;
    }

    /**
     * Sets the value of the purpose property.
     *
     * @param value allowed object is
     *              {@link StructuredStringType }
     */
    public void setPurpose(StructuredStringType value) {
        this.purpose = value;
    }

    /**
     * Describes the coverage of the sub-group unit. Detailed information on Topical, Temporal, and Spatial Coverage is contained here. Note that Coverage at this level should be inclusive all lower level modules or section. Lower level descriptions serve to constrain coverage within the scope described here.
     *
     * @return possible object is
     * {@link CoverageType }
     */
    public CoverageType getCoverage() {
        return coverage;
    }

    /**
     * Sets the value of the coverage property.
     *
     * @param value allowed object is
     *              {@link CoverageType }
     */
    public void setCoverage(CoverageType value) {
        this.coverage = value;
    }

    /**
     * Allows the use of a controlled vocabulary to list all of the units of analysis used in the sub-group. Should be repeated to describe multiple units of analysis.Gets the value of the analysisUnit property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the analysisUnit property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getAnalysisUnit().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CodeValueType }
     */
    public List<CodeValueType> getAnalysisUnit() {
        if (analysisUnit == null) {
            analysisUnit = new ArrayList<CodeValueType>();
        }
        return this.analysisUnit;
    }

    /**
     * A narrative of the units of analysis in the sub-group unit. Uses an InternationalString to support multiple languages.
     *
     * @return possible object is
     * {@link InternationalStringType }
     */
    public InternationalStringType getAnalysisUnitsCovered() {
        return analysisUnitsCovered;
    }

    /**
     * Sets the value of the analysisUnitsCovered property.
     *
     * @param value allowed object is
     *              {@link InternationalStringType }
     */
    public void setAnalysisUnitsCovered(InternationalStringType value) {
        this.analysisUnitsCovered = value;
    }

    /**
     * Briefly describes the kind of data documented in the logical product(s) of a sub-group unit. Examples include survey data, census/enumeration data, administrative data, measurement data, assessment data, demographic data, voting data, etc. Supports the use of an external controlled vocabulary.Gets the value of the kindOfData property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the kindOfData property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getKindOfData().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link KindOfDataType }
     */
    public List<KindOfDataType> getKindOfData() {
        if (kindOfData == null) {
            kindOfData = new ArrayList<KindOfDataType>();
        }
        return this.kindOfData;
    }

    /**
     * Contains references to other materials relevant to the sub-group unit, whether in DDI form or external. Links can be made from items in this section to any identifiable element in the instance. Best practice is to include OtherMaterial inside the maintainable containing the objects that are related to the OtherMaterial.Gets the value of the otherMaterial property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the otherMaterial property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getOtherMaterial().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link OtherMaterialType }
     */
    public List<OtherMaterialType> getOtherMaterial() {
        if (otherMaterial == null) {
            otherMaterial = new ArrayList<OtherMaterialType>();
        }
        return this.otherMaterial;
    }

    /**
     * Embargo information about the sub-group unit. References to embargo information in this section can be made from individual variables.Gets the value of the embargo property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the embargo property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getEmbargo().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link EmbargoType }
     */
    public List<EmbargoType> getEmbargo() {
        if (embargo == null) {
            embargo = new ArrayList<EmbargoType>();
        }
        return this.embargo;
    }

    /**
     * Gets the value of the conceptualComponentOrConceptualComponentReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the conceptualComponentOrConceptualComponentReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getConceptualComponentOrConceptualComponentReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ConceptualComponentType }
     * {@link ReferenceType }
     */
    public List<Object> getConceptualComponentOrConceptualComponentReference() {
        if (conceptualComponentOrConceptualComponentReference == null) {
            conceptualComponentOrConceptualComponentReference = new ArrayList<Object>();
        }
        return this.conceptualComponentOrConceptualComponentReference;
    }

    /**
     * Gets the value of the dataCollectionOrDataCollectionReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the dataCollectionOrDataCollectionReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDataCollectionOrDataCollectionReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link DataCollectionType }
     * {@link ReferenceType }
     */
    public List<Object> getDataCollectionOrDataCollectionReference() {
        if (dataCollectionOrDataCollectionReference == null) {
            dataCollectionOrDataCollectionReference = new ArrayList<Object>();
        }
        return this.dataCollectionOrDataCollectionReference;
    }

    /**
     * Gets the value of the baseLogicalProductOrLogicalProductReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the baseLogicalProductOrLogicalProductReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getBaseLogicalProductOrLogicalProductReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link JAXBElement }{@code <}{@link LogicalProductType }{@code >}
     * {@link JAXBElement }{@code <}{@link BaseLogicalProductType }{@code >}
     * {@link JAXBElement }{@code <}{@link ReferenceType }{@code >}
     */
    public List<JAXBElement<?>> getBaseLogicalProductOrLogicalProductReference() {
        if (baseLogicalProductOrLogicalProductReference == null) {
            baseLogicalProductOrLogicalProductReference = new ArrayList<JAXBElement<?>>();
        }
        return this.baseLogicalProductOrLogicalProductReference;
    }

    /**
     * Gets the value of the physicalDataProductOrPhysicalDataProductReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the physicalDataProductOrPhysicalDataProductReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPhysicalDataProductOrPhysicalDataProductReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link PhysicalDataProductType }
     * {@link ReferenceType }
     */
    public List<Object> getPhysicalDataProductOrPhysicalDataProductReference() {
        if (physicalDataProductOrPhysicalDataProductReference == null) {
            physicalDataProductOrPhysicalDataProductReference = new ArrayList<Object>();
        }
        return this.physicalDataProductOrPhysicalDataProductReference;
    }

    /**
     * Gets the value of the physicalInstanceOrPhysicalInstanceReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the physicalInstanceOrPhysicalInstanceReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPhysicalInstanceOrPhysicalInstanceReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link PhysicalInstanceType }
     * {@link ReferenceType }
     */
    public List<Object> getPhysicalInstanceOrPhysicalInstanceReference() {
        if (physicalInstanceOrPhysicalInstanceReference == null) {
            physicalInstanceOrPhysicalInstanceReference = new ArrayList<Object>();
        }
        return this.physicalInstanceOrPhysicalInstanceReference;
    }

    /**
     * Gets the value of the archiveOrArchiveReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the archiveOrArchiveReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getArchiveOrArchiveReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ArchiveType }
     * {@link ReferenceType }
     */
    public List<Object> getArchiveOrArchiveReference() {
        if (archiveOrArchiveReference == null) {
            archiveOrArchiveReference = new ArrayList<Object>();
        }
        return this.archiveOrArchiveReference;
    }

    /**
     * Gets the value of the ddiProfileOrDDIProfileReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the ddiProfileOrDDIProfileReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDDIProfileOrDDIProfileReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link DDIProfileType }
     * {@link ReferenceType }
     */
    public List<Object> getDDIProfileOrDDIProfileReference() {
        if (ddiProfileOrDDIProfileReference == null) {
            ddiProfileOrDDIProfileReference = new ArrayList<Object>();
        }
        return this.ddiProfileOrDDIProfileReference;
    }

    /**
     * Gets the value of the comparisonOrComparisonReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the comparisonOrComparisonReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getComparisonOrComparisonReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ComparisonType }
     * {@link ReferenceType }
     */
    public List<Object> getComparisonOrComparisonReference() {
        if (comparisonOrComparisonReference == null) {
            comparisonOrComparisonReference = new ArrayList<Object>();
        }
        return this.comparisonOrComparisonReference;
    }

    /**
     * Gets the value of the studyUnitOrStudyUnitReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the studyUnitOrStudyUnitReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getStudyUnitOrStudyUnitReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link StudyUnitType }
     * {@link ReferenceType }
     */
    public List<Object> getStudyUnitOrStudyUnitReference() {
        if (studyUnitOrStudyUnitReference == null) {
            studyUnitOrStudyUnitReference = new ArrayList<Object>();
        }
        return this.studyUnitOrStudyUnitReference;
    }

    /**
     * Gets the value of the subGroupOrSubGroupReference property.
     * <p>
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the subGroupOrSubGroupReference property.
     * <p>
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSubGroupOrSubGroupReference().add(newItem);
     * </pre>
     * <p>
     * <p>
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link SubGroupType }
     * {@link ReferenceType }
     */
    public List<Object> getSubGroupOrSubGroupReference() {
        if (subGroupOrSubGroupReference == null) {
            subGroupOrSubGroupReference = new ArrayList<Object>();
        }
        return this.subGroupOrSubGroupReference;
    }

    /**
     * Gets the value of the time property.
     *
     * @return possible object is
     * {@link TimeGroupCodeType }
     */
    public TimeGroupCodeType getTime() {
        if (time == null) {
            return TimeGroupCodeType.T_0;
        } else {
            return time;
        }
    }

    /**
     * Sets the value of the time property.
     *
     * @param value allowed object is
     *              {@link TimeGroupCodeType }
     */
    public void setTime(TimeGroupCodeType value) {
        this.time = value;
    }

    /**
     * Gets the value of the captureInstrument property.
     *
     * @return possible object is
     * {@link InstrumentGroupCodeType }
     */
    public InstrumentGroupCodeType getCaptureInstrument() {
        if (captureInstrument == null) {
            return InstrumentGroupCodeType.I_0;
        } else {
            return captureInstrument;
        }
    }

    /**
     * Sets the value of the captureInstrument property.
     *
     * @param value allowed object is
     *              {@link InstrumentGroupCodeType }
     */
    public void setCaptureInstrument(InstrumentGroupCodeType value) {
        this.captureInstrument = value;
    }

    /**
     * Gets the value of the panel property.
     *
     * @return possible object is
     * {@link PanelGroupCodeType }
     */
    public PanelGroupCodeType getPanel() {
        if (panel == null) {
            return PanelGroupCodeType.P_0;
        } else {
            return panel;
        }
    }

    /**
     * Sets the value of the panel property.
     *
     * @param value allowed object is
     *              {@link PanelGroupCodeType }
     */
    public void setPanel(PanelGroupCodeType value) {
        this.panel = value;
    }

    /**
     * Gets the value of the geography property.
     *
     * @return possible object is
     * {@link GeographyGroupCodeType }
     */
    public GeographyGroupCodeType getGeography() {
        if (geography == null) {
            return GeographyGroupCodeType.G_0;
        } else {
            return geography;
        }
    }

    /**
     * Sets the value of the geography property.
     *
     * @param value allowed object is
     *              {@link GeographyGroupCodeType }
     */
    public void setGeography(GeographyGroupCodeType value) {
        this.geography = value;
    }

    /**
     * Gets the value of the dataProduct property.
     *
     * @return possible object is
     * {@link DataProductGroupCodeType }
     */
    public DataProductGroupCodeType getDataProduct() {
        if (dataProduct == null) {
            return DataProductGroupCodeType.D_0;
        } else {
            return dataProduct;
        }
    }

    /**
     * Sets the value of the dataProduct property.
     *
     * @param value allowed object is
     *              {@link DataProductGroupCodeType }
     */
    public void setDataProduct(DataProductGroupCodeType value) {
        this.dataProduct = value;
    }

    /**
     * Gets the value of the languageRelationship property.
     *
     * @return possible object is
     * {@link LanguageGroupCodeType }
     */
    public LanguageGroupCodeType getLanguageRelationship() {
        if (languageRelationship == null) {
            return LanguageGroupCodeType.L_0;
        } else {
            return languageRelationship;
        }
    }

    /**
     * Sets the value of the languageRelationship property.
     *
     * @param value allowed object is
     *              {@link LanguageGroupCodeType }
     */
    public void setLanguageRelationship(LanguageGroupCodeType value) {
        this.languageRelationship = value;
    }

    /**
     * Gets the value of the userDefinedGroupProperty property.
     *
     * @return possible object is
     * {@link String }
     */
    public String getUserDefinedGroupProperty() {
        return userDefinedGroupProperty;
    }

    /**
     * Sets the value of the userDefinedGroupProperty property.
     *
     * @param value allowed object is
     *              {@link String }
     */
    public void setUserDefinedGroupProperty(String value) {
        this.userDefinedGroupProperty = value;
    }

    /**
     * Gets the value of the userDefinedGroupPropertyValue property.
     *
     * @return possible object is
     * {@link String }
     */
    public String getUserDefinedGroupPropertyValue() {
        return userDefinedGroupPropertyValue;
    }

    /**
     * Sets the value of the userDefinedGroupPropertyValue property.
     *
     * @param value allowed object is
     *              {@link String }
     */
    public void setUserDefinedGroupPropertyValue(String value) {
        this.userDefinedGroupPropertyValue = value;
    }

    /**
     * Gets the value of the isInheritable property.
     *
     * @return possible object is
     * {@link Boolean }
     */
    public boolean isIsInheritable() {
        if (isInheritable == null) {
            return true;
        } else {
            return isInheritable;
        }
    }

    /**
     * Sets the value of the isInheritable property.
     *
     * @param value allowed object is
     *              {@link Boolean }
     */
    public void setIsInheritable(Boolean value) {
        this.isInheritable = value;
    }

}
